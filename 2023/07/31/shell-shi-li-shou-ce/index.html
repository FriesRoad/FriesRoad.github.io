<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="shell实例手册, luyao&#39;s home">
    <meta name="description" content="默认摘要">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>shell实例手册 | luyao&#39;s home</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">luyao&#39;s home</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">luyao&#39;s home</div>
        <div class="logo-desc">
            
            欢迎参观我的博客,期待您留下宝贵的建议~
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://friesroad.github.io/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://friesroad.github.io/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">shell实例手册</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%B5%8B%E8%AF%95/">
                                <span class="chip bg-color">测试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/" class="post-category">
                                默认分类
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-07-31
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-07-31
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    24.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    107 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-文件"><a href="#1-文件" class="headerlink" title="1 文件"></a>1 文件</h2><pre><code>ls -rtl                                    # 按时间倒叙列出所有目录和文件 ll -rt
touch file                                 # 创建空白文件
rm -rf dirname                             # 不提示删除非空目录(-r:递归删除 -f强制)
dos2unix                                   # windows文本转linux文本
unix2dos                                   # linux文本转windows文本
enca filename                              # 查看编码  安装 yum install -y enca
md5sum                                     # 查看md5值
ln sourcefile newfile                      # 硬链接
ln -s sourcefile newfile                   # 符号连接
readlink -f /data                          # 查看连接真实目录
cat file | nl |less                        # 查看上下翻页且显示行号  q退出
head                                       # 查看文件开头内容
head -c 10m                                # 截取文件中10M内容
split -C 10M                               # 将文件切割大小为10M -C按行
tail -f file                               # 查看结尾 监视日志文件
tail -F file                               # 监视日志并重试, 针对文件被mv的情况可以持续读取
file                                       # 检查文件类型
umask                                      # 更改默认权限
uniq                                       # 删除重复的行
uniq -c                                    # 重复的行出现次数
uniq -u                                    # 只显示不重复行
paste a b                                  # 将两个文件合并用tab键分隔开
paste -d'+' a b                            # 将两个文件合并指定'+'符号隔开
paste -s a                                 # 将多行数据合并到一行用tab键隔开
chattr +i /etc/passwd                      # 不得任意改变文件或目录 -i去掉锁 -R递归
more                                       # 向下分面器
locate aaa                                 # 搜索
wc -l file                                 # 查看行数
cp filename{,.bak}                         # 快速备份一个文件
\cp a b                                    # 拷贝不提示 既不使用别名 cp -i
rev                                        # 将行中的字符逆序排列
comm -12 2 3                               # 行和行比较匹配
echo "10.45aa" |cksum                      # 字符串转数字编码，可做校验，也可用于文件校验
iconv -f gbk -t utf8 source.txt &gt; new.txt  # 转换编码
xxd /boot/grub/stage1                      # 16进制查看
hexdump -C /boot/grub/stage1               # 16进制查看
rename source new file                     # 重命名 可正则
watch -d -n 1 'df; ls -FlAt /path'         # 实时某个目录下查看最新改动过的文件
cp -v  /dev/dvd  /rhel4.6.iso9660          # 制作镜像
diff suzu.c suzu2.c  &gt; sz.patch            # 制作补丁
patch suzu.c &lt; sz.patch                    # 安装补丁

sort排序{

    -t                                     # 指定排序时所用的栏位分隔字符
    -n                                     # 依照数值的大小排序
    -r                                     # 以相反的顺序来排序
    -f                                     # 排序时，将小写字母视为大写字母
    -d                                     # 排序时，处理英文字母、数字及空格字符外，忽略其他的字符
    -c                                     # 检查文件是否已经按照顺序排序
    -b                                     # 忽略每行前面开始处的空格字符
    -M                                     # 前面3个字母依照月份的缩写进行排序
    -k                                     # 指定域
    -m                                     # 将几个排序好的文件进行合并
    -T                                     # 指定临时文件目录,默认在/tmp
    -o                                     # 将排序后的结果存入指定的文        

    sort -n                                # 按数字排序
    sort -nr                               # 按数字倒叙
    sort -u                                # 过滤重复行
    sort -m a.txt c.txt                    # 将两个文件内容整合到一起
    sort -n -t' ' -k 2 -k 3 a.txt          # 第二域相同，将从第三域进行升降处理
    sort -n -t':' -k 3r a.txt              # 以:为分割域的第三域进行倒叙排列
    sort -k 1.3 a.txt                      # 从第三个字母起进行排序
    sort -t" " -k 2n -u  a.txt             # 以第二域进行排序，如果遇到重复的，就删除

}

find查找{

    # linux文件无创建时间
    # Access 使用时间
    # Modify 内容修改时间
    # Change 状态改变时间(权限、属主)
    # 时间默认以24小时为单位,当前时间到向前24小时为0天,向前48-72小时为2天
    # -and 且 匹配两个条件 参数可以确定时间范围 -mtime +2 -and -mtime -4
    # -or 或 匹配任意一个条件

    find /etc -name "*http*"                                # 按文件名查找
    find . -type f                                          # 查找某一类型文件
    find / -perm                                            # 按照文件权限查找
    find / -user                                            # 按照文件属主查找
    find / -group                                           # 按照文件所属的组来查找文件
    find / -atime -n                                        # 文件使用时间在N天以内
    find / -atime +n                                        # 文件使用时间在N天以前
    find / -mtime +n                                        # 文件内容改变时间在N天以前
    find / -ctime +n                                        # 文件状态改变时间在N天前
    find / -mmin +30                                        # 按分钟查找内容改变
    find / -size +1000000c -print                           # 查找文件长度大于1M字节的文件
    find /etc -name "*passwd*" -exec grep "xuesong" {} \;   # 按名字查找文件传递给-exec后命令
    find . -name 't*' -exec basename {} \;                  # 查找文件名,不取路径
    find . -type f -name "err*" -exec  rename err ERR {} \; # 批量改名(查找err 替换为 ERR {}文件
    find path -name *name1* -or -name *name2*               # 查找任意一个关键字

}

vim编辑器{

    # 常用配置
    set smartindent
    set tabstop=4
    set shiftwidth=4
    set expandtab
    set softtabstop=4
    set noautoindent
    set nosmartindent
    set paste
    set clipboard=unnamed

    gconf-editor           # 配置编辑器
    /etc/vimrc             # 配置文件路径
    vim +24 file           # 打开文件定位到指定行
    vim file1 file2        # 打开多个文件
    vim  -r file           # 恢复上次异常关闭的文件 .file.swp 
    vim -O2 file1 file2    # 垂直分屏
    vim -on file1 file2    # 水平分屏
    Ctrl+ U                # 向前翻页
    Ctrl+ D                # 向后翻页
    Ctrl+ww                # 在窗口间切换
    Ctrl+w +or-or=         # 增减高度
    :sp filename           # 上下分割打开新文件
    :vs filename           # 左右分割打开新文件
    :set nu                # 打开行号
    :set nonu              # 取消行号
    :nohl                  # 取消高亮
    :set paste             # 取消缩进
    :set autoindent        # 设置自动缩进
    :set ff                # 查看文本格式
    :set binary            # 改为unix格式
    :%s/str/newstr/g       # 全部替换
    :200                   # 跳转到200  1 文件头
    G                      # 跳到行尾
    dd                     # 删除当前行 并复制 可直接p粘贴
    11111dd                # 删除11111行，可用来清空文件
    r                      # 替换单个字符
    R                      # 替换多个字符
    u                      # 撤销上次操作
    *                      # 全文匹配当前光标所在字符串
    $                      # 行尾
    0                      # 行首
    X                      # 文档加密
    v =                    # 自动格式化代码
    Ctrl+v                 # 可视模式
    Ctrl+v I ESC           # 多行操作
    Ctrl+v s ESC           # 批量取消注释

}

归档解压缩{

    tar zxvpf gz.tar.gz  dir                         # 解包指定tar.gz中的内容  不指定目录则全解压
    tar zcvpf /$path/gz.tar.gz *                     # 打包gz 注意*最好用相对路径
    tar zcf /$path/gz.tar.gz *                       # 打包正确不提示
    tar ztvpf gz.tar.gz                              # 查看gz
    tar xvf 1.tar -C dir                             # 解包tar 放到指定目录
    tar -cvf 1.tar *                                 # 打包tar
    tar tvf 1.tar                                    # 查看tar
    tar -rvf 1.tar filename                          # 给tar追加文件
    tar --exclude=/home/dmtsai --exclude=*.tar -zcvf myfile.tar.gz /home/* /etc      # 打包/home, /etc ，但排除 /home/dmtsai
    tar -N "2005/06/01" -zcvf home.tar.gz /home      # 在 /home 当中，比 2005/06/01 新的文件才备份
    tar -zcvfh home.tar.gz /home                     # 打包目录中包括连接目录
    tar zcf - ./ | ssh root@IP "tar zxf - -C /xxxx"  # 一边压缩一边解压
    zgrep str 1.gz                                   # 查看压缩包中文件字符行
    bzip2  -dv 1.tar.bz2                             # 解压bzip2
    bzip2 -v 1.tar                                   # bzip2压缩
    bzcat                                            # 查看bzip2
    gzip file                                        # 直接压缩文件 # 压缩后源文件消失
    gunzip file.gz                                   # 直接解压文件 # 解压后源文件消失
    gzip -r dir/                                     # 递归压缩目录
    gzip  -r -d dir/                                 # 递归解压目录
    gzip -dv 1.tar.gz                                # 解压gzip到tar
    gzip -v 1.tar                                    # 压缩tar到gz
    unzip zip.zip                                    # 解压zip
    zip zip.zip *                                    # 压缩zip
    rar a rar.rar *.jpg                              # 压缩文件为rar包
    unrar x rar.rar                                  # 解压rar包

}

文件ACL权限控制{

    getfacl 1.test                      # 查看文件ACL权限
    setfacl -R -m u:xuesong:rw- 1.test  # 对文件增加用户的读写权限 -R 递归

}

svn{

    --force # 强制覆盖
    /usr/bin/svn --username user --password passwd co  $Code  ${SvnPath}src/                 # 检出整个项目
    /usr/bin/svn --username user --password passwd up  $Code  ${SvnPath}src/                 # 更新项目
    /usr/bin/svn --username user --password passwd export  $Code$File ${SvnPath}src/$File    # 导出个别文件
    /usr/bin/svn --username user --password passwd export -r 版本号 svn路径 本地路径 --force   # 导出指定版本

}

git{

    git clone git@10.10.10.10:gittest.git  ./gittest/  # 克隆项目到指定目录
    git clone  -b develop --depth=1 http://git.a.com/d.git   # 克隆指定分支 克隆一层
    git status                                         # Show the working tree(工作树) status
    git log -n 1 --stat                                # 查看最后一次日志文件
    git branch -a                                      # 列出远程跟踪分支(remote-tracking branches)和本地分支
    git checkout developing                            # 切换到developing分支
    git checkout -b release                            # 切换分支没有从当前分支创建
    git checkout -b release origin/master              # 从远程分支创建本地镜像分支
    git push origin --delete release                   # 从远端删除分区，服务端有可能设置保护不允许删除
    git push origin release                            # 把本地分支提交到远程
    git pull                                           # 更新项目 需要cd到项目目录中
    git fetch -f -p                                    # 抓取远端代码但不合并到当前
    git reset --hard origin/master                     # 和远端同步分支
    git add .                                          # 更新所有文件
    git commit -m "gittest up"                         # 提交操作并添加备注
    git push                                           # 正式提交到远程git服务器
    git push [-u origin master]                        # 正式提交到远程git服务器(master分支)
    git tag [-a] dev-v-0.11.54 [-m 'fix #67']          # 创建tag,名为dev-v-0.11.54,备注fix #67
    git tag -l dev-v-0.11.54                           # 查看tag(dev-v-0.11.5)
    git push origin --tags                             # 提交tag
    git reset --hard                                   # 本地恢复整个项目
    git rm -r -n --cached  ./img                       # -n执行命令时,不会删除任何文件,而是展示此命令要删除的文件列表预览
    git rm -r --cached  ./img                          # 执行删除命令 需要commit和push让远程生效
    git init --bare smc-content-check.git              # 初始化新git项目  需要手动创建此目录并给git用户权限 chown -R git:git smc-content-check.git
    git config --global credential.helper store        # 记住密码
    git config [--global] user.name "your name"        # 设置你的用户名, 希望在一个特定的项目中使用不同的用户或e-mail地址, 不要--global选项
    git config [--global] user.email "your email"      # 设置你的e-mail地址, 每次Git提交都会使用该信息
    git config [--global] user.name                    # 查看用户名
    git config [--global] user.email                   # 查看用户e-mail
    git config --global --edit                         # 编辑~/.gitconfig(User-specific)配置文件, 值优先级高于/etc/gitconfig(System-wide)
    git config --edit                                  # 编辑.git/config(Repository specific)配置文件, 值优先级高于~/.gitconfig
    git cherry-pick  &lt;commit id&gt;                       # 用于把另一个本地分支的commit修改应用到当前分支 需要push到远程
    git log --pretty=format:'%h: %s' 9378b62..HEAD     # 查看指定范围更新操作 commit id
    git config --global core.ignorecase false          # 设置全局大小写敏感
    git ls-remote --heads origin refs/heads/test       # 查看

    从远端拉一份新的{
        # You have not concluded your merge (MERGE_HEAD exists)  git拉取失败
        git fetch --hard origin/master
        git reset --hard origin/master
    }

    删除远程分支并新建{
        git checkout master
        git branch -r -d origin/test       # 删除远程分支  但有时候并没有删除 可以尝试使用下面的语句
        git push origin :test              # 推送一个空分支到远程分支，相当于删除远程分支
        git branch -d test                 # 删除本地test分支, -D 强制
        git branch -a |grep test
        git checkout -b test
        git push origin test

        git reset --hard origin/test 
    }

    迁移git项目{
        git branch -r | grep -v '\-&gt;' | while read remote; do git branch --track "${remote#origin/}" "$remote"; done
        git fetch --all
        git pull --all
        git remote set-url origin git@git.github.cn:server/gw.git
        git push --all
    }
}

恢复rm删除的文件{

    # debugfs针对 ext2   # ext3grep针对 ext3   # extundelete针对 ext4
    df -T   # 首先查看磁盘分区格式
    umount /data/     # 卸载挂载,数据丢失请首先卸载挂载,或重新挂载只读
    ext3grep /dev/sdb1 --ls --inode 2         # 记录信息继续查找目录下文件inode信息
    ext3grep /dev/sdb1 --ls --inode 131081    # 此处是inode
    ext3grep /dev/sdb1 --restore-inode 49153  # 记录下inode信息开始恢复目录

}

openssl{

    openssl rand 15 -base64            # 口令生成
    openssl sha1 filename              # 哈希算法校验文件
    openssl md5 filename               # MD5校验文件
    openssl base64   filename.txt      # base64编码/解码文件(发送邮件附件之类功能会可以使用)
    openssl base64 -d   filename.bin   # base64编码/解码二进制文件
    openssl enc -aes-128-cbc   filename.aes-128-cbc                  # 加密文档
    # 推荐使用的加密算法是bf(Blowfish)和-aes-128-cbc(运行在CBC模式的128位密匙AES加密算法)，加密强度有保障
    openssl enc -d -aes-128-cbc -in filename.aes-128-cbc &gt; filename  # 解密文档

}
</code></pre>
<h2 id="2-软件"><a href="#2-软件" class="headerlink" title="2 软件"></a>2 软件</h2><pre><code>rpm{

    rpm -ivh lynx          # rpm安装
    rpm -e lynx            # 卸载包
    rpm -e lynx --nodeps   # 强制卸载
    rpm -qa                # 查看所有安装的rpm包
    rpm -qa | grep lynx    # 查找包是否安装
    rpm -ql                # 软件包路径
    rpm -Uvh               # 升级包
    rpm --test lynx        # 测试
    rpm -qc                # 软件包配置文档
    rpm --initdb           # 初始化rpm 数据库
    rpm --rebuilddb        # 重建rpm数据库  在rpm和yum无响应的情况使用 先 rm -f /var/lib/rpm/__db.00* 在重建

}

yum{

    yum list                 # 所有软件列表
    yum install 包名          # 安装包和依赖包
    yum -y update            # 升级所有包版本,依赖关系，系统版本内核都升级
    yum -y update 软件包名    # 升级指定的软件包
    yum -y upgrade           # 不改变软件设置更新软件，系统版本升级，内核不改变
    yum search mail          # yum搜索相关包
    yum grouplist            # 软件包组
    yum -y groupinstall "Virtualization"   # 安装软件包组
    repoquery -ql gstreamer  # 不安装软件查看包含文件
    yum clean all            # 清除var下缓存

}

yum使用epel源{

    # 包下载地址: http://download.fedoraproject.org/pub/epel   # 选择版本5\6\7
    rpm -Uvh  http://mirrors.hustunique.com/epel//6/x86_64/epel-release-6-8.noarch.rpm

    # 自适配版本
    yum install epel-release

}

自定义yum源{

    find /etc/yum.repos.d -name "*.repo" -exec mv {} {}.bak \;

    vim /etc/yum.repos.d/yum.repo
    [yum]
    #http
    baseurl=http://10.0.0.1/centos5.5
    #挂载iso
    #mount -o loop CentOS-5.8-x86_64-bin-DVD-1of2.iso /data/iso/
    #本地
    #baseurl=file:///data/iso/
    enable=1

    #导入key
    rpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5

}

编译{

    源码安装{

        ./configure --help                   # 查看所有编译参数
        ./configure  --prefix=/usr/local/    # 配置参数
        make                                 # 编译
        # make -j 8                          # 多线程编译,速度较快,但有些软件不支持
        make install                         # 安装包
        make clean                           # 清除编译结果

    }

    perl程序编译{

        perl Makefile.PL
        make
        make test
        make install

    }

    python程序编译{

        python file.py

        # 源码包编译安装
        python setup.py build
        python setup.py install

    }

    编译c程序{

        gcc -g hello.c -o hello

    }

}
</code></pre>
<h2 id="3-系统"><a href="#3-系统" class="headerlink" title="3 系统"></a>3 系统</h2><pre><code>wall                                          # 给其它用户发消息
whereis ls                                    # 搜索程序名，而且只搜索二进制文件
which                                         # 查找命令是否存在,及存放位置
locate                                        # 不是实时查找，查找的结果不精确，但查找速度很快 每天更新 /var/lib/locatedb
clear                                         # 清空整个屏幕
reset                                         # 重新初始化屏幕
cal                                           # 显示月历
echo -n 123456 | md5sum                       # md5加密
mkpasswd                                      # 随机生成密码   -l位数 -C大小 -c小写 -d数字 -s特殊字符
netstat -ntupl | grep port                    # 是否打开了某个端口
ntpdate cn.pool.ntp.org                       # 同步时间, pool.ntp.org: public ntp time server for everyone(http://www.pool.ntp.org/zh/)
tzselect                                      # 选择时区 #+8=(5 9 1 1) # (TZ='Asia/Shanghai'; export TZ)括号内写入 /etc/profile
/sbin/hwclock -w                              # 时间保存到硬件
/etc/shadow                                   # 账户影子文件
LANG=en                                       # 修改语言
vim /etc/sysconfig/i18n                       # 修改编码  LANG="en_US.UTF-8"
export LC_ALL=C                               # 强制字符集
vi /etc/hosts                                 # 查询静态主机名
alias                                         # 别名
watch uptime                                  # 监测命令动态刷新 监视
ipcs -a                                       # 查看Linux系统当前单个共享内存段的最大值
ldconfig                                      # 动态链接库管理命令
ldd `which cmd`                               # 查看命令的依赖库
dist-upgrade                                  # 会改变配置文件,改变旧的依赖关系，改变系统版本
/boot/grub/grub.conf                          # grub启动项配置
ps -mfL &lt;PID&gt;                                 # 查看指定进程启动的线程 线程数受 max user processes 限制
ps uxm |wc -l                                 # 查看当前用户占用的进程数 [包括线程]  max user processes
top -p  PID -H                                # 查看指定PID进程及线程
lsof |wc -l                                   # 查看当前文件句柄数使用数量  open files
lsof |grep /lib                               # 查看加载库文件
sysctl -a                                     # 查看当前所有系统内核参数
sysctl -p                                     # 修改内核参数/etc/sysctl.conf，让/etc/rc.d/rc.sysinit读取生效
strace -p pid                                 # 跟踪系统调用
ps -eo "%p %C  %z  %a"|sort -k3 -n            # 把进程按内存使用大小排序
strace uptime 2&gt;&amp;1|grep open                  # 查看命令打开的相关文件
grep Hugepagesize /proc/meminfo               # 内存分页大小
mkpasswd -l 8  -C 2 -c 2 -d 4 -s 0            # 随机生成指定类型密码
echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies    # 使TCP SYN Cookie 保护生效  # "SYN Attack"是一种拒绝服务的攻击方式
grep Swap  /proc/25151/smaps |awk '{a+=$2}END{print a}'    # 查询某pid使用的swap大小
redir --lport=33060 --caddr=10.10.10.78 --cport=3306       # 端口映射 yum安装 用supervisor守护

开机启动脚本顺序{

    /etc/profile
    /etc/profile.d/*.sh
    ~/bash_profile
    ~/.bashrc
    /etc/bashrc

}

进程管理{

    ps -eaf               # 查看所有进程
    kill -9 PID           # 强制终止某个PID进程
    kill -15 PID          # 安全退出 需程序内部处理信号
    cmd &amp;                 # 命令后台运行
    nohup cmd &amp;           # 后台运行不受shell退出影响
    ctrl+z                # 将前台放入后台(暂停)
    jobs                  # 查看后台运行程序
    bg 2                  # 启动后台暂停进程
    fg 2                  # 调回后台进程
    pstree                # 进程树
    vmstat 1 9            # 每隔一秒报告系统性能信息9次
    sar                   # 查看cpu等状态
    lsof file             # 显示打开指定文件的所有进程
    lsof -i:32768         # 查看端口的进程
    renice +1 180         # 把180号进程的优先级加1
    exec sh a.sh          # 子进程替换原来程序的pid， 避免supervisor无法强制杀死进程

    ps{

        ps aux |grep -v USER | sort -nk +4 | tail       # 显示消耗内存最多的10个运行中的进程，以内存使用量排序.cpu +3
        # USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
        %CPU     # 进程的cpu占用率
        %MEM     # 进程的内存占用率
        VSZ      # 进程虚拟大小,单位K(即总占用内存大小,包括真实内存和虚拟内存)
        RSS      # 进程使用的驻留集大小即实际物理内存大小
        START    # 进程启动时间和日期
        占用的虚拟内存大小 = VSZ - RSS

        ps -eo pid,lstart,etime,args         # 查看进程启动时间

    }

    top{

        前五行是系统整体的统计信息。
        第一行: 任务队列信息，同 uptime 命令的执行结果。内容如下：
            01:06:48 当前时间
            up 1:22 系统运行时间，格式为时:分
            1 user 当前登录用户数
            load average: 0.06, 0.60, 0.48 系统负载，即任务队列的平均长度。
            三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。

        第二、三行:为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：
            Tasks: 29 total 进程总数
            1 running 正在运行的进程数
            28 sleeping 睡眠的进程数
            0 stopped 停止的进程数
            0 zombie 僵尸进程数
            Cpu(s): 0.3% us 用户空间占用CPU百分比
            1.0% sy 内核空间占用CPU百分比
            0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比
            98.7% id 空闲CPU百分比
            0.0% wa 等待输入输出的CPU时间百分比
            0.0% hi
            0.0% si

        第四、五行:为内存信息。内容如下：
            Mem: 191272k total 物理内存总量
            173656k used 使用的物理内存总量
            17616k free 空闲内存总量
            22052k buffers 用作内核缓存的内存量
            Swap: 192772k total 交换区总量
            0k used 使用的交换区总量
            192772k free 空闲交换区总量
            123988k cached 缓冲的交换区总量。
            内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，
            该数值即为这些内容已存在于内存中的交换区的大小。
            相应的内存再次被换出时可不必再对交换区写入。

        进程信息区,各列的含义如下:  # 显示各个进程的详细信息

        序号 列名    含义
        a   PID      进程id
        b   PPID     父进程id
        c   RUSER    Real user name
        d   UID      进程所有者的用户id
        e   USER     进程所有者的用户名
        f   GROUP    进程所有者的组名
        g   TTY      启动进程的终端名。不是从终端启动的进程则显示为 ?
        h   PR       优先级
        i   NI       nice值。负值表示高优先级，正值表示低优先级
        j   P        最后使用的CPU，仅在多CPU环境下有意义
        k   %CPU     上次更新到现在的CPU时间占用百分比
        l   TIME     进程使用的CPU时间总计，单位秒
        m   TIME+    进程使用的CPU时间总计，单位1/100秒
        n   %MEM     进程使用的物理内存百分比
        o   VIRT     进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
        p   SWAP     进程使用的虚拟内存中，被换出的大小，单位kb。
        q   RES      进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
        r   CODE     可执行代码占用的物理内存大小，单位kb
        s   DATA     可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
        t   SHR      共享内存大小，单位kb
        u   nFLT     页面错误次数
        v   nDRT     最后一次写入到现在，被修改过的页面数。
        w   S        进程状态。
            D=不可中断的睡眠状态
            R=运行
            S=睡眠
            T=跟踪/停止
            Z=僵尸进程 父进程在但并不等待子进程
        x   COMMAND  命令名/命令行
        y   WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名
        z   Flags    任务标志，参考 sched.h

    }

    列出正在占用swap的进程{

        #!/bin/bash
        echo -e "PID\t\tSwap\t\tProc_Name"
        # 拿出/proc目录下所有以数字为名的目录（进程名是数字才是进程，其他如sys,net等存放的是其他信息）
        for pid in `ls -l /proc | grep ^d | awk '{ print $9 }'| grep -v [^0-9]`
        do
            # 让进程释放swap的方法只有一个：就是重启该进程。或者等其自动释放。放
            # 如果进程会自动释放，那么我们就不会写脚本来找他了，找他都是因为他没有自动释放。
            # 所以我们要列出占用swap并需要重启的进程，但是init这个进程是系统里所有进程的祖先进程
            # 重启init进程意味着重启系统，这是万万不可以的，所以就不必检测他了，以免对系统造成影响。
            if [ $pid -eq 1 ];then continue;fi
            grep -q "Swap" /proc/$pid/smaps 2&gt;/dev/null
            if [ $? -eq 0 ];then
                swap=$(grep Swap /proc/$pid/smaps \
                    | gawk '{ sum+=$2;} END{ print sum }')
                proc_name=$(ps aux | grep -w "$pid" | grep -v grep \
                    | awk '{ for(i=11;i&lt;=NF;i++){ printf("%s ",$i); }}')
                if [ $swap -gt 0 ];then
                    echo -e "${pid}\t${swap}\t${proc_name}"
                fi
            fi
        done | sort -k2 -n | awk -F'\t' '{
            pid[NR]=$1;
            size[NR]=$2;
            name[NR]=$3;
        }
        END{
            for(id=1;id&lt;=length(pid);id++)
            {
                if(size[id]&lt;1024)
                    printf("%-10s\t%15sKB\t%s\n",pid[id],size[id],name[id]);
                else if(size[id]&lt;1048576)
                    printf("%-10s\t%15.2fMB\t%s\n",pid[id],size[id]/1024,name[id]);
                else
                    printf("%-10s\t%15.2fGB\t%s\n",pid[id],size[id]/1048576,name[id]);
            }
        }'

    }

    linux操作系统提供的信号{

        kill -l                    # 查看linux提供的信号
        trap "echo aaa"  2 3 15    # shell使用 trap 捕捉退出信号

        # 发送信号一般有两种原因:
        #   1(被动式)  内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号
        #   2(主动式)  通过系统调用kill来向指定进程发送信号
        # 进程结束信号 SIGTERM 和 SIGKILL 的区别:  SIGTERM 比较友好，进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下，假如进程正在进行作业而且不能中断，那么进程可以忽略这个SIGTERM信号。
        # 如果一个进程收到一个SIGUSR1信号，然后执行信号绑定函数，第二个SIGUSR2信号又来了，第一个信号没有被处理完毕的话，第二个信号就会丢弃。

        SIGHUP  1          A     # 终端挂起或者控制进程终止
        SIGINT  2          A     # 键盘终端进程(如control+c)
        SIGQUIT 3          C     # 键盘的退出键被按下
        SIGILL  4          C     # 非法指令
        SIGABRT 6          C     # 由abort(3)发出的退出指令
        SIGFPE  8          C     # 浮点异常
        SIGKILL 9          AEF   # Kill信号  立刻停止
        SIGSEGV 11         C     # 无效的内存引用
        SIGPIPE 13         A     # 管道破裂: 写一个没有读端口的管道
        SIGALRM 14         A     # 闹钟信号 由alarm(2)发出的信号
        SIGTERM 15         A     # 终止信号,可让程序安全退出 kill -15
        SIGUSR1 30,10,16   A     # 用户自定义信号1
        SIGUSR2 31,12,17   A     # 用户自定义信号2
        SIGCHLD 20,17,18   B     # 子进程结束自动向父进程发送SIGCHLD信号
        SIGCONT 19,18,25         # 进程继续（曾被停止的进程）
        SIGSTOP 17,19,23   DEF   # 终止进程
        SIGTSTP 18,20,24   D     # 控制终端（tty）上按下停止键
        SIGTTIN 21,21,26   D     # 后台进程企图从控制终端读
        SIGTTOU 22,22,27   D     # 后台进程企图从控制终端写

        缺省处理动作一项中的字母含义如下:
            A  缺省的动作是终止进程
            B  缺省的动作是忽略此信号，将该信号丢弃，不做处理
            C  缺省的动作是终止进程并进行内核映像转储(dump core),内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。
            D  缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）
            E  信号不能被捕获
            F  信号不能被忽略
    }

    系统性能状态{

        vmstat 1 9

        r      # 等待执行的任务数。当这个值超过了cpu线程数，就会出现cpu瓶颈。
        b      # 等待IO的进程数量,表示阻塞的进程。
        swpd   # 虚拟内存已使用的大小，如大于0，表示机器物理内存不足，如不是程序内存泄露，那么该升级内存。
        free   # 空闲的物理内存的大小
        buff   # 已用的buff大小，对块设备的读写进行缓冲
        cache  # cache直接用来记忆我们打开的文件,给文件做缓冲，(把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)
        inact  # 非活跃内存大小，即被标明可回收的内存，区别于free和active -a选项时显示
        active # 活跃的内存大小 -a选项时显示
        si   # 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露，要查找耗内存进程解决掉。
        so   # 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。
        bi   # 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte
        bo   # 块设备每秒发送的块数量，例如读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。
        in   # 每秒CPU的中断次数，包括时间中断。in和cs这两个值越大，会看到由内核消耗的cpu时间会越多
        cs   # 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用。
        us   # 用户进程执行消耗cpu时间(user time)  us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施
        sy   # 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
        id   # 空闲 CPU时间，一般来说，id + us + sy = 100,一般认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。
        wt   # 等待IOCPU时间。Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。

        如果 r 经常大于4，且id经常少于40，表示cpu的负荷很重。
        如果 pi po 长期不等于0，表示内存不足。
        如果 b 队列经常大于3，表示io性能不好。

    }

}

日志管理{

    history                      # 历时命令默认1000条
    HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S "   # 让history命令显示具体时间
    history  -c                  # 清除记录命令
    cat $HOME/.bash_history      # 历史命令记录文件
    lastb -a                     # 列出登录系统失败的用户相关信息  清空二进制日志记录文件 echo &gt; /var/log/btmp
    last                         # 查看登陆过的用户信息  清空二进制日志记录文件 echo &gt; /var/log/wtmp   默认打开乱码
    who /var/log/wtmp            # 查看登陆过的用户信息
    lastlog                      # 用户最后登录的时间
    tail -f /var/log/messages    # 系统日志
    tail -f /var/log/secure      # ssh日志

}

man{
    man 2 read   # 查看read函数的文档
    1 使用者在shell中可以操作的指令或可执行档
    2 系统核心可呼叫的函数与工具等
    3 一些常用的函数(function)与函数库(library),大部分是C的函数库(libc)
    4 装置档案的说明，通常在/dev下的档案
    5 设定档或者是某些档案的格式
    6 游戏games
    7 惯例与协定等，例如linux档案系统、网络协定、ascll code等说明
    8 系统管理员可用的管理指令
    9 跟kernel有关的文件
}

selinux{

    sestatus -v                    # 查看selinux状态
    getenforce                     # 查看selinux模式
    setenforce 0                   # 设置selinux为宽容模式(可避免阻止一些操作)
    semanage port -l               # 查看selinux端口限制规则
    semanage port -a -t http_port_t -p tcp 8000  # 在selinux中注册端口类型
    vi /etc/selinux/config         # selinux配置文件
    SELINUX=enfoceing              # 关闭selinux 把其修改为  SELINUX=disabled

}

查看剩余内存{

    free -m
    #-/+ buffers/cache:       6458       1649
    #6458M为真实使用内存  1649M为真实剩余内存(剩余内存+缓存+缓冲器)
    #linux会利用所有的剩余内存作为缓存，所以要保证linux运行速度，就需要保证内存的缓存大小

}

系统信息{

    uname -a              # 查看Linux内核版本信息
    cat /proc/version     # 查看内核版本
    cat /etc/issue        # 查看系统版本
    lsb_release -a        # 查看系统版本  需安装 centos-release
    locale -a             # 列出所有语系
    locale                # 当前环境变量中所有编码
    hwclock               # 查看时间
    who                   # 当前在线用户
    w                     # 当前在线用户
    whoami                # 查看当前用户名
    logname               # 查看初始登陆用户名
    uptime                # 查看服务器启动时间
    sar -n DEV 1 10       # 查看网卡网速流量
    dmesg                 # 显示开机信息
    lsmod                 # 查看内核模块

}

硬件信息{

    more /proc/cpuinfo                                       # 查看cpu信息
    lscpu                                                    # 查看cpu信息
    cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c    # 查看cpu型号和逻辑核心数
    getconf LONG_BIT                                         # cpu运行的位数
    cat /proc/cpuinfo | grep 'physical id' |sort| uniq -c    # 物理cpu个数
    cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l     # 结果大于0支持64位
    cat /proc/cpuinfo|grep flags                             # 查看cpu是否支持虚拟化   pae支持半虚拟化  IntelVT 支持全虚拟化
    more /proc/meminfo                                       # 查看内存信息
    dmidecode                                                # 查看全面硬件信息
    dmidecode | grep "Product Name"                          # 查看服务器型号
    dmidecode | grep -P -A5 "Memory\s+Device" | grep Size | grep -v Range       # 查看内存插槽
    cat /proc/mdstat                                         # 查看软raid信息
    cat /proc/scsi/scsi                                      # 查看Dell硬raid信息(IBM、HP需要官方检测工具)
    lspci                                                    # 查看硬件信息
    lspci|grep RAID                                          # 查看是否支持raid
    lspci -vvv |grep Ethernet                                # 查看网卡型号
    lspci -vvv |grep Kernel|grep driver                      # 查看驱动模块
    modinfo tg2                                              # 查看驱动版本(驱动模块)
    ethtool -i em1                                           # 查看网卡驱动版本
    ethtool em1                                              # 查看网卡带宽

}

终端快捷键{

    Ctrl+A        　    # 行前
    Ctrl+E        　    # 行尾
    Ctrl+S        　    # 终端锁屏
    Ctrl+Q        　　  # 解锁屏
    Ctrl+D      　　    # 退出

}

开机启动模式{

    vi /etc/inittab
    id:3:initdefault:    # 3为多用户命令
    #ca::ctrlaltdel:/sbin/shutdown -t3 -r now   # 注释此行 禁止 ctrl+alt+del 关闭计算机

}

终端提示显示{

    echo $PS1                   # 环境变量控制提示显示
    PS1='[\u@ \H \w \A \@#]\$'
    PS1='[\u@\h \W]\$'
    export PS1='[\[\e[32m\]\[\e[31m\]\u@\[\e[36m\]\h \w\[\e[m\]]\$ '     # 高亮显示终端

}

定时任务{

    at 5pm + 3 days /bin/ls  # 单次定时任务 指定三天后下午5:00执行/bin/ls

    crontab -e               # 编辑周期任务
    #分钟  小时    天  月  星期   命令或脚本
    1,30  1-3/2    *   *   *      命令或脚本  &gt;&gt; file.log 2&gt;&amp;1
    echo "40 7 * * 2 /root/sh"&gt;&gt;/var/spool/cron/work    # 普通用户可直接写入定时任务
    crontab -l                                          # 查看自动周期性任务
    crontab -r                                          # 删除自动周期性任务
    cron.deny和cron.allow                               # 禁止或允许用户使用周期任务
    service crond start|stop|restart                    # 启动自动周期性服务
    * * * * *  echo "d" &gt;&gt;d$(date +\%Y\%m\%d).log       # 让定时任务直接生成带日期的log  需要转义%

}

date{

    星期日[SUN] 星期一[MON] 星期二[TUE] 星期三[WED] 星期四[THU] 星期五[FRI] 星期六[SAT]
    一月[JAN] 二月[FEB] 三月[MAR] 四月[APR] 五月[MAY] 六月[JUN] 七月[JUL] 八月[AUG] 九月[SEP] 十月[OCT] 十一月[NOV] 十二月[DEC]

    date -s 20091112                     # 设日期
    date -s 18:30:50                     # 设时间
    date -d "7 days ago" +%Y%m%d         # 7天前日期
    date -d "5 minute ago" +%H:%M        # 5分钟前时间
    date -d "1 month ago" +%Y%m%d        # 一个月前
    date -d '1 days' +%Y-%m-%d           # 一天后
    date -d '1 hours' +%H:%M:%S          # 一小时后
    date +%Y-%m-%d -d '20110902'         # 日期格式转换
    date +%Y-%m-%d_%X                    # 日期和时间
    date +%N                             # 纳秒
    date -d "2012-08-13 14:00:23" +%s    # 换算成秒计算(1970年至今的秒数)
    date -d "@1363867952" +%Y-%m-%d-%T   # 将时间戳换算成日期
    date -d "1970-01-01 UTC 1363867952 seconds" +%Y-%m-%d-%T  # 将时间戳换算成日期
    date -d "`awk -F. '{print $1}' /proc/uptime` second ago" +"%Y-%m-%d %H:%M:%S"    # 格式化系统启动时间(多少秒前)

}

limits.conf{

    ulimit -SHn 65535  # 临时设置文件描述符大小 进程最大打开文件柄数 还有socket最大连接数, 等同配置 nofile
    ulimit -SHu 65535  # 临时设置用户最大进程数
    ulimit -a          # 查看

    /etc/security/limits.conf

    # 文件描述符大小  open files
    # lsof |wc -l   查看当前文件句柄数使用数量
    * soft nofile 16384         # 设置太大，进程使用过多会把机器拖死
    * hard nofile 32768

    # 用户最大进程数  max user processes
    # echo $((`ps uxm |wc -l`-`ps ux |wc -l`))  查看当前用户占用的进程数 [包括线程]
    user soft nproc 16384
    user hard nproc 32768

    # 如果/etc/security/limits.d/有配置文件，将会覆盖/etc/security/limits.conf里的配置
    # 即/etc/security/limits.d/的配置文件里就不要有同样的参量设置
    /etc/security/limits.d/90-nproc.conf    # centos6.3的默认这个文件会覆盖 limits.conf
    user soft nproc 16384
    user hard nproc 32768

    sysctl -p    # 修改配置文件后让系统生效

}

随机分配端口范围{

    # 本机连其它端口用的
    echo "10000 65535" &gt; /proc/sys/net/ipv4/ip_local_port_range

}

百万长链接设置{

    # 内存消耗需要较大
    vim /root/.bash_profile
    # 添加如下2行,退出bash重新登陆
    # 一个进程不能使用超过NR_OPEN文件描述符
    echo 20000500 &gt; /proc/sys/fs/nr_open
    # 当前用户最大文件数
    ulimit -n 10000000

}

core崩溃文件查看{

    gdb  core.13844
    bt   # 查看函数调用信息(堆栈)

}


libc.so故障修复{

    # 由于升级glibc导致libc.so不稳定,突然报错,幸好还有未退出的终端
    grep: error while loading shared libraries: /lib64/libc.so.6: ELF file OS ABI invalid

    # 看看当前系统有多少版本 libc.so
    ls /lib64/libc-[tab]

    # 更改环境变量指向其他 libc.so 文件测试
    export LD_PRELOAD=/lib64/libc-2.7.so    # 如果不改变LD_PRELOAD变量,ln不能用,需要使用 /sbin/sln 命令做链接

    # 当前如果好使了，在执行下面强制替换软链接。如不好使，测试其他版本的libc.so文件
    ln -f -s /lib64/libc-2.7.so /lib64/libc.so.6

}

无法分配内存 {

    fork: Cannot allocate memory

    # 报错不一定是内存不够用，进程数或者线程数满了也会报这个错误， 可以适当增加 kernel.pid_max 的值，
    cat /proc/sys/kernel/pid_max  # 默认3.2w

}

sudo{

    echo myPassword | sudo -S ls /tmp  # 直接输入sudo的密码非交互,从标准输入读取密码而不是终端设备
    visudo                             # sudo命令权限添加  /etc/sudoers
    用户  别名(可用all)=NOPASSWD:命令1,命令2
    user  ALL=NOPASSWD:/bin/su         # 免root密码切换root身份
    wangming linuxfan=NOPASSWD:/sbin/apache start,/sbin/apache restart
    UserName ALL=(ALL) ALL
    UserName ALL=(ALL) NOPASSWD: ALL
    peterli        ALL=(ALL)       NOPASSWD:/sbin/service
    Defaults requiretty                # sudo不允许后台运行,注释此行既允许
    Defaults !visiblepw                # sudo不允许远程,去掉!既允许

}

grub开机启动项添加{

    vim /etc/grub.conf
    title ms-dos
    rootnoverify (hd0,0)
    chainloader +1

}

stty{

    #stty时一个用来改变并打印终端行设置的常用命令

    stty iuclc          # 在命令行下禁止输出大写
    stty -iuclc         # 恢复输出大写
    stty olcuc          # 在命令行下禁止输出小写
    stty -olcuc         # 恢复输出小写
    stty size           # 打印出终端的行数和列数
    stty eof "string"   # 改变系统默认ctrl+D来表示文件的结束
    stty -echo          # 禁止回显
    stty echo           # 打开回显
    stty -echo;read;stty echo;read  # 测试禁止回显
    stty igncr          # 忽略回车符
    stty -igncr         # 恢复回车符
    stty erase '#'      # 将#设置为退格字符
    stty erase '^?'     # 恢复退格字符

    定时输入{

        timeout_read(){
            timeout=$1
            old_stty_settings=`stty -g`　　# save current settings
            stty -icanon min 0 time 100　　# set 10seconds,not 100seconds
            eval read varname　　          # =read $varname
            stty "$old_stty_settings"　　  # recover settings
        }

        read -t 10 varname    # 更简单的方法就是利用read命令的-t选项

    }

    检测用户按键{

        #!/bin/bash
        old_tty_settings=$(stty -g)   # 保存老的设置(为什么?).
        stty -icanon
        Keypress=$(head -c1)          # 或者使用$(dd bs=1 count=1 2&gt; /dev/null)
        echo "Key pressed was \""$Keypress"\"."
        stty "$old_tty_settings"      # 恢复老的设置.
        exit 0

    }

}

iptables{

    内建三个表：nat mangle 和 filter
    filter预设规则表，有INPUT、FORWARD 和 OUTPUT 三个规则链
    vi /etc/sysconfig/iptables    # 配置文件
    INPUT    # 进入
    FORWARD  # 转发
    OUTPUT   # 出去
    ACCEPT   # 将封包放行
    REJECT   # 拦阻该封包
    DROP     # 丢弃封包不予处理
    -A       # 在所选择的链(INPUT等)末添加一条或更多规则
    -D       # 删除一条
    -E       # 修改
    -p       # tcp、udp、icmp    0相当于所有all    !取反
    -P       # 设置缺省策略(与所有链都不匹配强制使用此策略)
    -s       # IP/掩码    (IP/24)    主机名、网络名和清楚的IP地址 !取反
    -j       # 目标跳转，立即决定包的命运的专用内建目标
    -i       # 进入的（网络）接口 [名称] eth0
    -o       # 输出接口[名称]
    -m       # 模块
    --sport  # 源端口
    --dport  # 目标端口

    iptables -F                        # 将防火墙中的规则条目清除掉  # 注意: iptables -P INPUT ACCEPT
    iptables-restore &lt; 规则文件        # 导入防火墙规则
    /etc/init.d/iptables save          # 保存防火墙设置
    /etc/init.d/iptables restart       # 重启防火墙服务
    iptables -L -n                     # 查看规则
    iptables -t nat -nL                # 查看转发

    iptables实例{

        iptables -L INPUT                   # 列出某规则链中的所有规则
        iptables -X allowed                 # 删除某个规则链 ,不加规则链，清除所有非内建的
        iptables -Z INPUT                   # 将封包计数器归零
        iptables -N allowed                 # 定义新的规则链
        iptables -P INPUT DROP              # 定义过滤政策
        iptables -A INPUT -s 192.168.1.1    # 比对封包的来源IP   # ! 192.168.0.0/24  ! 反向对比
        iptables -A INPUT -d 192.168.1.1    # 比对封包的目的地IP
        iptables -A INPUT -i eth0           # 比对封包是从哪片网卡进入
        iptables -A FORWARD -o eth0         # 比对封包要从哪片网卡送出 eth+表示所有的网卡
        iptables -A INPUT -p tcp            # -p ! tcp 排除tcp以外的udp、icmp。-p all所有类型
        iptables -D INPUT 8                 # 从某个规则链中删除一条规则
        iptables -D INPUT --dport 80 -j DROP         # 从某个规则链中删除一条规则
        iptables -R INPUT 8 -s 192.168.0.1 -j DROP   # 取代现行规则
        iptables -I INPUT 8 --dport 80 -j ACCEPT     # 插入一条规则
        iptables -A INPUT -i eth0 -j DROP            # 其它情况不允许
        iptables -A INPUT -p tcp -s IP -j DROP       # 禁止指定IP访问
        iptables -A INPUT -p tcp -s IP --dport port -j DROP               # 禁止指定IP访问端口
        iptables -A INPUT -s IP -p tcp --dport port -j ACCEPT             # 允许在IP访问指定端口
        iptables -A INPUT -p tcp --dport 22 -j DROP                       # 禁止使用某端口
        iptables -A INPUT -i eth0 -p icmp -m icmp --icmp-type 8 -j DROP   # 禁止icmp端口
        iptables -A INPUT -i eth0 -p icmp -j DROP                         # 禁止icmp端口
        iptables -t filter -A INPUT -i eth0 -p tcp --syn -j DROP                  # 阻止所有没有经过你系统授权的TCP连接
        iptables -A INPUT -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT   # IP包流量限制
        iptables -A INPUT -i eth0 -s 192.168.62.1/32 -p icmp -m icmp --icmp-type 8 -j ACCEPT  # 除192.168.62.1外，禁止其它人ping我的主机
        iptables -A INPUT -p tcp -m tcp --dport 80 -m state --state NEW -m recent --update --seconds 5 --hitcount 20 --rttl --name WEB --rsource -j DROP  # 可防御cc攻击(未测试)

    }

    iptables配置实例文件{

        # Generated by iptables-save v1.2.11 on Fri Feb  9 12:10:37 2007
        *filter
        :INPUT ACCEPT [637:58967]
        :FORWARD DROP [0:0]
        :OUTPUT ACCEPT [5091:1301533]
        # 允许的IP或IP段访问 建议多个
        -A INPUT -s 127.0.0.1 -p tcp -j ACCEPT
        -A INPUT -s 192.168.0.0/255.255.0.0 -p tcp -j ACCEPT
        # 开放对外开放端口
        -A INPUT -p tcp --dport 80 -j ACCEPT
        # 指定某端口针对IP开放
        -A INPUT -s 192.168.10.37 -p tcp --dport 22 -j ACCEPT
        # 拒绝所有协议(INPUT允许)
        -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP
        # 允许已建立的或相关连的通行
        -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
        # 拒绝ping
        -A INPUT -p tcp -m tcp -j REJECT --reject-with icmp-port-unreachable
        COMMIT
        # Completed on Fri Feb  9 12:10:37 2007

    }

    iptables配置实例{

        # 允许某段IP访问任何端口
        iptables -A INPUT -s 192.168.0.3/24 -p tcp -j ACCEPT
        # 设定预设规则 (拒绝所有的数据包，再允许需要的,如只做WEB服务器.还是推荐三个链都是DROP)
        iptables -P INPUT DROP
        iptables -P FORWARD DROP
        iptables -P OUTPUT ACCEPT
        # 注意: 直接设置这三条会掉线
        # 开启22端口
        iptables -A INPUT -p tcp --dport 22 -j ACCEPT
        # 如果OUTPUT 设置成DROP的，要写上下面一条
        iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
        # 注:不写导致无法SSH.其他的端口一样,OUTPUT设置成DROP的话,也要添加一条链
        # 如果开启了web服务器,OUTPUT设置成DROP的话,同样也要添加一条链
        iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT
        # 做WEB服务器,开启80端口 ,其他同理
        iptables -A INPUT -p tcp --dport 80 -j ACCEPT
        # 做邮件服务器,开启25,110端口
        iptables -A INPUT -p tcp --dport 110 -j ACCEPT
        iptables -A INPUT -p tcp --dport 25 -j ACCEPT
        # 允许icmp包通过,允许ping
        iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话)
        iptables -A INPUT -p icmp -j ACCEPT  (INPUT设置成DROP的话)
        # 允许loopback!(不然会导致DNS无法正常关闭等问题)
        IPTABLES -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP)
        IPTABLES -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP)

    }

    centos6的iptables基本配置{
        *filter
        :INPUT ACCEPT [0:0]
        :FORWARD ACCEPT [0:0]
        :OUTPUT ACCEPT [0:0]
        -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
        -A INPUT -p icmp -j ACCEPT
        -A INPUT -i lo -j ACCEPT
        -A INPUT -s 222.186.135.61 -p tcp -j ACCEPT
        -A INPUT -p tcp  --dport 80 -j ACCEPT
        -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
        -A INPUT -j REJECT --reject-with icmp-host-prohibited
        -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP
        -A FORWARD -j REJECT --reject-with icmp-host-prohibited
        COMMIT
    }

    添加网段转发{

        # 例如通过vpn上网
        echo 1 &gt; /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能
        iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE  # 添加网段转发
        iptables -t nat -A POSTROUTING -s 10.0.0.0/255.0.0.0 -o eth0 -j SNAT --to 192.168.10.158  # 原IP网段经过哪个网卡IP出去
        iptables -t nat -nL                # 查看转发

    }

    端口映射{

        # 内网通过有外网IP的机器映射端口
        # 内网主机添加路由
        route add -net 10.10.20.0 netmask 255.255.255.0 gw 10.10.20.111     # 内网需要添加默认网关，并且网关开启转发
        # 网关主机
        echo 1 &gt; /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能
        iptables -t nat -A PREROUTING -d 外网IP  -p tcp --dport 9999 -j DNAT --to 10.10.20.55:22    # 进入
        iptables -t nat -A POSTROUTING -s 10.10.20.0/24 -j SNAT --to 外网IP                         # 转发回去
        iptables -t nat -nL                # 查看转发

    }

}
</code></pre>
<h2 id="4-服务"><a href="#4-服务" class="headerlink" title="4 服务"></a>4 服务</h2><pre><code>/etc/init.d/sendmail start                   # 启动服务
/etc/init.d/sendmail stop                    # 关闭服务
/etc/init.d/sendmail status                  # 查看服务当前状态
/date/mysql/bin/mysqld_safe --user=mysql &amp;   # 启动mysql后台运行
/bin/systemctl restart  mysqld.service       # centos7启动服务
vi /etc/rc.d/rc.local                        # 开机启动执行  可用于开机启动脚本
/etc/rc.d/rc3.d/S55sshd                      # 开机启动和关机关闭服务连接    # S开机start  K关机stop  55级别 后跟服务名
ln -s -f /date/httpd/bin/apachectl /etc/rc.d/rc3.d/S15httpd   # 将启动程序脚本连接到开机启动目录
ipvsadm -ln                                  # lvs查看后端负载机并发
ipvsadm -C                                   # lvs清除规则
xm list                                      # 查看xen虚拟主机列表
virsh                                        # 虚拟化(xen\kvm)管理工具  yum groupinstall Virtual*
./bin/httpd -M                               # 查看httpd加载模块
httpd -t -D DUMP_MODULES                     # rpm包httpd查看加载模块
echo 内容| /bin/mail -s "标题" 收件箱 -f 发件人       # 发送邮件
"`echo "内容"|iconv -f utf8 -t gbk`" | /bin/mail -s "`echo "标题"|iconv -f utf8 -t gbk`" 收件箱     # 解决邮件乱码
/usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg   # 检测nagios配置文件

chkconfig{

    chkconfig service on|off|set             # 设置非独立服务启状态
    chkconfig --level 35   httpd   off       # 让服务不自动启动
    chkconfig --level 35   httpd   on        # 让服务自动启动 35指的是运行级别
    chkconfig --list                         # 查看所有服务的启动状态
    chkconfig --list |grep httpd             # 查看某个服务的启动状态
    chkconfig –-list [service]               # 查看服务的状态

}

systemctl{

    systemctl is-active *.service      # 查看服务是否运行
    systemctl is-enabled *.service     # 查询服务是否开机启动
    systemctl mask *.service           # 注销指定服务
    systemctl unmask cups.service      # 取消注销cups服务
    systemctl enable *.service         # 开机运行服务
    systemctl disable *.service        # 取消开机运行
    systemctl start *.service          # 启动服务
    systemctl stop *.service           # 停止服务
    systemctl restart *.service        # 重启服务
    systemctl reload *.service         # 重新加载服务配置文件
    systemctl status *.service         # 查询服务运行状态
    systemctl --failed                 # 显示启动失败的服务
    systemctl poweroff                 # 系统关机
    systemctl reboot                   # 重新启动
    systemctl rescue                   # 强制进入救援模式
    systemctl emergency                # 强制进入紧急救援模式
    systemctl list-dependencies        # 查看当前运行级别target(mult-user)启动了哪些服务
    systemctl list-unit-files          # 查看开机启动的状态
    journalctl -r -u elasticsearch.service  # 查看日志 r倒序 u服务名
    /etc/systemd/system/falcon-agent.service
        [Unit]
        Description=This is zuiyou monitor agent
        After=network.target remote-fs.target nss-lookup.target

        [Service]
        User= root
        Type=simple
        PIDFile=/opt/falcon-agent/var/app.pid
        ExecStartPre=/usr/bin/rm -f /opt/falcon-agent/var/app.pid
        ExecStart=/opt/falcon-agent/control start
        ExecReload=/bin/kill -s HUP $MAINPID
        KillMode=process
        KillSignal=SIGQUIT
        TimeoutStopSec=5
        PrivateTmp=true
        Restart=always
        LimitNOFILE=infinity

        [Install]
        WantedBy=multi-user.target

    systemctl daemon-reload           # 加载配置

}


nginx{

    yum install -y make gcc  openssl-devel pcre-devel  bzip2-devel libxml2 libxml2-devel curl-devel libmcrypt-devel libjpeg libjpeg-devel libpng libpng-devel openssl

    groupadd nginx
    useradd nginx -g nginx -M -s /sbin/nologin

    mkdir -p /opt/nginx-tmp

    wget http://labs.frickle.com/files/ngx_cache_purge-1.6.tar.gz
    tar fxz ngx_cache_purge-1.6.tar.gz
    # ngx_cache_purge 清除指定url缓存
    # 假设一个URL为 http://192.168.12.133/test.txt
    # 通过访问      http://192.168.12.133/purge/test.txt  就可以清除该URL的缓存。

    tar zxvpf nginx-1.4.4.tar.gz
    cd nginx-1.4.4

    # ./configure --help
    # --with                 # 默认不加载 需指定编译此参数才使用
    # --without              # 默认加载，可用此参数禁用
    # --add-module=path      # 添加模块的路径
    # --add-module=/opt/ngx_module_upstream_check \         # nginx 代理状态页面
    # ngx_module_upstream_check  编译前需要打对应版本补丁 patch -p1 &lt; /opt/nginx_upstream_check_module/check_1.2.6+.patch
    # --add-module=/opt/ngx_module_memc \                   # 将请求页面数据存放在 memcached中
    # --add-module=/opt/ngx_module_lua \                    # 支持lua脚本 yum install lua-devel lua

    ./configure \
    --user=nginx \
    --group=nginx \
    --prefix=/usr/local/nginx \
    --with-http_ssl_module \
    --with-http_realip_module \
    --with-http_gzip_static_module \
    --with-http_stub_status_module \
    --add-module=/opt/ngx_cache_purge-1.6 \
    --http-client-body-temp-path=/opt/nginx-tmp/client \
    --http-proxy-temp-path=/opt/nginx-tmp/proxy \
    --http-fastcgi-temp-path=/opt/nginx-tmp/fastcgi \
    --http-uwsgi-temp-path=/opt/nginx-tmp/uwsgi \
    --http-scgi-temp-path=/opt/nginx-tmp/scgi

    make &amp;&amp; make install

    /usr/local/nginx/sbin/nginx –t             # 检查Nginx配置文件 但并不执行
    /usr/local/nginx/sbin/nginx -t -c /opt/nginx/conf/nginx.conf  # 检查Nginx配置文件
    /usr/local/nginx/sbin/nginx                # 启动nginx
    /usr/local/nginx/sbin/nginx -s reload      # 重载配置
    /usr/local/nginx/sbin/nginx -s stop        # 关闭nginx服务

}

elasticsearch{

    vim /etc/sysctl.conf
    vm.max_map_count = 262144

    vim /etc/security/limits.conf
    * soft memlock unlimited
    * hard memlock unlimited
    sysctl -p

    curl 'localhost:9200/_cat/health?v'                    # 健康检查
    curl 'localhost:9200/_cat/nodes?v'                     # 获取集群的节点列表
    curl 'localhost:9200/_cat/indices?v'                   # 列出所有索引
    curl 127.0.0.1:9200/indexname -XDELETE                 # 删除索引
    curl -XGET http://localhost:9200/_cat/shards           # 查看分片
    curl '127.0.0.1:9200/_cat/indices'                     # 查分片同步  unassigned_shards  # 没同步完成

}


mysql常用命令{

    # mysql 可视化工具 MySQL Workbench

    mysqlcheck -uroot -p -S mysql.sock --optimize --databases account       # 检查、修复、优化MyISAM表
    mysqlbinlog slave-relay-bin.000001              # 查看二进制日志
    mysqladmin -h myhost -u root -p create dbname   # 创建数据库

    flush privileges;             # 刷新
    show databases;               # 显示所有数据库
    use dbname;                   # 打开数据库
    show tables;                  # 显示选中数据库中所有的表
    desc tables;                  # 查看表结构
    drop database name;           # 删除数据库
    drop table name;              # 删除表
    create database name;         # 创建数据库
    select column from table;     # 查询
    show processlist;             # 查看mysql进程
    show full processlist;        # 显示进程全的语句
    select user();                # 查看所有用户
    show slave status\G;          # 查看主从状态
    show variables;               # 查看所有参数变量
    show status;                  # 运行状态
    show table status             # 查看表的引擎状态
    show grants for user@'%'                                    # 查看用户权限
    drop table if exists user                                   # 表存在就删除
    create table if not exists user                             # 表不存在就创建
    select host,user,password from user;                        # 查询用户权限 先use mysql
    create table ka(ka_id varchar(6),qianshu int);              # 创建表
    show variables like 'character_set_%';                      # 查看系统的字符集和排序方式的设定
    show variables like '%timeout%';                            # 查看超时相关参数
    delete from user where user='';                             # 删除空用户
    delete from user where user='sss' and host='localhost' ;    # 删除用户
    drop user 'sss'@'localhost';                                # 使用此方法删除用户更为靠谱
    ALTER TABLE mytable ENGINE = MyISAM ;                       # 改变现有的表使用的存储引擎
    SHOW TABLE STATUS from  dbname  where Name='tablename';     # 查询表引擎
    mysql -uroot -p -A -ss -h10.10.10.5 -e "show databases;"    # shell中获取数据不带表格 -ss参数
    CREATE TABLE innodb (id int, title char(20)) ENGINE = INNODB                     # 创建表指定存储引擎的类型(MyISAM或INNODB)
    grant replication slave on *.* to 'user'@'%' identified by 'pwd';                # 创建主从复制用户
    ALTER TABLE player ADD INDEX weekcredit_faction_index (weekcredit, faction);     # 添加索引
    alter table name add column accountid(column)  int(11) NOT NULL(column);         # 插入字段
    update host set monitor_state='Y',hostname='xuesong' where ip='192.168.1.1';     # 更新数据
    select * from information_schema.processlist where command!='sleep';             # 查看当前进程
    select * from atable where name='on' AND t&lt;15 AND host LIKE '10%' limit 1,10;    # 多条件查询
    show create database ops_deploy;                                                 # 查看数据库编码
    show create table updatelog;                                                     # 查看数据库表编码
    alter database ops_deploy CHARACTER SET utf8;                                    # 修改数据库编码
    alter table `updatelog` default character set utf8;                              # 修改表编码
    alter table `updatelog` convert to character set utf8;                           # 修改一张表的所有字段的编码格式

    自增表{

        create table xuesong  (id INTEGER  PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NOT NULL, age integer , sex CHAR(15) );  # 创建自增表
        insert into xuesong(name,age,sex) values(%s,%s,%s)  # 自增插入数据

    }

    登录mysql的命令{

        # 格式： mysql -h 主机地址 -u 用户名 -p 用户密码
        mysql -h110.110.110.110 -P3306 -uroot -p
        mysql -uroot -p -S /data1/mysql5/data/mysql.sock -A  --default-character-set=GBK

    }

    shell执行mysql命令{

        mysql -u root -p'123' xuesong &lt; file.sql   # 针对指定库执行sql文件中的语句,好处不需要转义特殊符号,一条语句可以换行.不指定库执行时语句中需要先use
        mysql -u$username -p$passwd -h$dbhost -P$dbport -A -e "
        use $dbname;
        delete from data where date=('$date1');
        "    # 执行多条mysql命令
        mysql -uroot -p -S mysql.sock -e "use db;alter table gift add column accountid  int(11) NOT NULL;flush privileges;"  2&gt;&amp;1 |grep -v Warning    # 不登陆mysql插入字段

    }


    mysql字符集相关{

        show variables like '%character%';      # 查看数据库中设置字符集的参数
        # character_set_client、character_set_connection 以及 character_set_results 这几个参数都是客户端的设置
        # character_set_system、character_set_server 以及 character_set_database 是指服务器端的设置。
        # 而对于这三个服务器端的参数来说的优先级是:
        # 列级字符集 &gt; 表级字符集 &gt; character_set_database &gt; character_set_server &gt; character_set_system

        show global variables like '%char%';                                 #查看RDS实例字符集相关参数设置
        show global variables like 'coll%';                                  #查看当前会话字符序相关参数设置
        show character set;                                                  #查看实例支持的字符集
        show collation;                                                      #查看实例支持的字符序
        show create table table_name \G                                      #查看表字符集设置
        show create database database_name \G                                #查看数据库字符集设置
        show create procedure procedure_name \G                              #查看存储过程字符集设置
        show procedure status \G                                             #查看存储过程字符集设置
        alter database db_name default charset utf8;                         #修改数据库的字符集 
        create database db_name character set utf8;                          #创建数据库时指定字符集
        alter table tab_name default charset utf8 collate utf8_general_ci;   #修改表字符集和字符序

        # 下面三条sql 分别将库 dbsdq , 表 tt2 , 表 tt2 中的 c2 列修改为utf8mb4 字符集
        alter database dbsdq character set utf8mb4 collate utf8mb4_unicode_ci;
        use dbsdq;
        alter table tt2 character set utf8mb4 collate utf8mb4_unicode_ci;
        alter table tt2 modify c2  varchar(10) character set utf8mb4;
        # 修改列时,当前列中的所有行都会立即转化为新的字符集;
        # alter table 会对表加元数据锁

    }

    备份数据库{

        mysqldump -h host -u root -p --default-character-set=utf8 dbname &gt;dbname_backup.sql               # 不包括库名，还原需先创建库，在use
        mysqldump -h host -u root -p --database --default-character-set=utf8 dbname &gt;dbname_backup.sql    # 包括库名，还原不需要创建库
        /bin/mysqlhotcopy -u root -p    # mysqlhotcopy只能备份MyISAM引擎
        mysqldump -u root -p -S mysql.sock --default-character-set=utf8 dbname table1 table2  &gt; /data/db.sql    # 备份表
        mysqldump -uroot -p123  -d database &gt; database.sql    # 备份数据库结构

        # 最小权限备份
        grant select on db_name.* to dbbackup@"localhost" Identified by "passwd";
        # --single-transaction  InnoDB有时间戳 只备份开始那一刻的数据,备份过程中的数据不会备份
        mysqldump -hlocalhost -P 3306 -u dbbackup --single-transaction  -p"passwd" --database dbname &gt;dbname.sql

        # xtrabackup备份需单独安装软件 优点: 速度快,压力小,可直接恢复主从复制
        innobackupex --user=root --password="" --defaults-file=/data/mysql5/data/my_3306.cnf --socket=/data/mysql5/data/mysql.sock --slave-info --stream=tar --tmpdir=/data/dbbackup/temp /data/dbbackup/ 2&gt;/data/dbbackup/dbbackup.log | gzip 1&gt;/data/dbbackup/db50.tar.gz

    }

    还原数据库{

        mysql -h host -u root -p dbname &lt; dbname_backup.sql
        source 路径.sql   # 登陆mysql后还原sql文件

    }

    赋权限{

        # 指定IP: $IP  本机: localhost   所有IP地址: %   # 通常指定多条
        grant all on zabbix.* to user@"$IP";             # 对现有账号赋予权限
        grant select on database.* to user@"%" Identified by "passwd";     # 赋予查询权限(没有用户，直接创建)
        grant all privileges on database.* to user@"$IP" identified by 'passwd';         # 赋予指定IP指定用户所有权限(不允许对当前库给其他用户赋权限)
        grant all privileges on database.* to user@"localhost" identified by 'passwd' with grant option;   # 赋予本机指定用户所有权限(允许对当前库给其他用户赋权限)
        grant select, insert, update, delete on database.* to user@'ip'identified by "passwd";   # 开放管理操作指令
        revoke all on *.* from user@localhost;     # 回收权限
        GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, EXECUTE, CREATE ROUTINE, ALTER ROUTINE ON `storemisc_dev`.* TO 'user'@'192.168.%'

    }

    更改密码{

        update user set password=password('passwd') where user='root'
        mysqladmin -u root password 'xuesong'

    }

    mysql忘记密码后重置{

        cd /data/mysql5
        /data/mysql5/bin/mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;
        use mysql;
        update user set password=password('123123') where user='root';

    }

    mysql主从复制失败恢复{

        slave stop;
        reset slave;
        change master to master_host='10.10.10.110',master_port=3306,master_user='repl',master_password='repl',master_log_file='master-bin.000010',master_log_pos=107,master_connect_retry=60;
        slave start;

    }

    sql语句使用变量{

        use xuesong;
        set @a=concat('my',weekday(curdate()));    # 组合时间变量
        set @sql := concat('CREATE TABLE IF NOT EXISTS ',@a,'( id INT(11) NOT NULL )');   # 组合sql语句
        select @sql;                    # 查看语句
        prepare create_tb from @sql;    # 准备
        execute create_tb;              # 执行

    }

    检测mysql主从复制延迟{

        1、在从库定时执行更新主库中的一个timeout数值
        2、同时取出从库中的timeout值对比判断从库与主库的延迟

    }

    死锁{

        show OPEN TABLES where In_use &gt; 0;                  # 查看当前锁信息
        show variables like 'innodb_print_all_deadlocks';   # 查看当前死锁参数
        set global innodb_print_all_deadlocks = 1;          # 设置死锁信息保存到错误日志
        innodb_print_all_deadlocks = 1                      # conf配置

    }

    mysql慢查询{

        select * from information_schema.processlist where command in ('Query') and time &gt;5\G      # 查询操作大于5S的进程

        开启慢查询日志{

            # 配置文件 /etc/my.conf
            [mysqld]
            log-slow-queries=/var/lib/mysql/slowquery.log         # 指定日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log
            long_query_time=5                                     # 记录超过的时间，默认为10s 建议0.5S
            log-queries-not-using-indexes                         # log下来没有使用索引的query,可以根据情况决定是否开启  可不加
            log-long-format                                       # 如果设置了，所有没有使用索引的查询也将被记录    可不加
            # 直接修改生效
            show variables like "%slow%";                         # 查看慢查询状态
            set global slow_query_log='ON';                       # 开启慢查询日志 变量可能不同，看上句查询出来的变量

        }

        mysqldumpslow慢查询日志查看{

            -s  # 是order的顺序，包括看了代码，主要有 c,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒序
            -t  # 是top n的意思，即为返回前面多少条的数据
            -g  # 后边可以写一个正则匹配模式，大小写不敏感的

            mysqldumpslow -s c -t 20 host-slow.log                # 访问次数最多的20个sql语句
            mysqldumpslow -s r -t 20 host-slow.log                # 返回记录集最多的20个sql
            mysqldumpslow -t 10 -s t -g "left join" host-slow.log # 按照时间返回前10条里面含有左连接的sql语句

            show global status like '%slow%';                     # 查看现在这个session有多少个慢查询
            show variables like '%slow%';                         # 查看慢查询日志是否开启，如果slow_query_log和log_slow_queries显示为on，说明服务器的慢查询日志已经开启
            show variables like '%long%';                         # 查看超时阀值
            desc select * from wei where text='xishizhaohua'\G;   # 扫描整张表 tepe:ALL  没有使用索引 key:NULL
            create index text_index on wei(text);                 # 创建索引

        }

        Percona Toolkit 慢日志分析工具

    }

    mysql操作次数查询{

        select * from information_schema.global_status;

        com_select
        com_delete
        com_insert
        com_update

    }

}

mongodb{

    # mongo可视管理工具 studio 3t  

    一、启动{

        # 不启动认证
        ./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/
        # 启动认证
        ./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/ --auth

        # 配置文件方式启动
        cat /opt/mongodb/mongodb.conf
          port=27017                       # 端口号
          fork=true                        # 以守护进程的方式运行，创建服务器进程
          auth=true                        # 开启用户认证
          logappend=true                   # 日志采用追加方式
          logpath=/opt/mongodb/mongodb.log # 日志输出文件路径
          dbpath=/opt/mongodb/data/        # 数据库路径
          shardsvr=true                    # 设置是否分片
          maxConns=600                     # 数据库的最大连接数
        ./mongod -f /opt/mongodb/mongodb.conf

        # 其他参数
        bind_ip         # 绑定IP  使用mongo登录需要指定对应IP
        journal         # 开启日志功能,降低单机故障的恢复时间,取代dur参数
        syncdelay       # 系统同步刷新磁盘的时间,默认60秒
        directoryperdb  # 每个db单独存放目录,建议设置.与mysql独立表空间类似
        repairpath      # 执行repair时的临时目录.如果没开启journal,出现异常重启,必须执行repair操作
        # mongodb没有参数设置内存大小.使用os mmap机制缓存数据文件,在数据量不超过内存的情况下,效率非常高.数据量超过系统可用内存会影响写入性能

    }

    二、关闭{

        # 方法一:登录mongodb
        ./mongo
        use admin
        db.shutdownServer()

        # 方法:kill传递信号  两种皆可
        kill -2 pid
        kill -15 pid

    }

    三、开启认证与用户管理{

        ./mongo                      # 先登录
        use admin                    # 切换到admin库
        db.addUser("root","123456")                     # 创建用户
        db.addUser('zhansan','pass',true)               # 如果用户的readOnly为true那么这个用户只能读取数据，添加一个readOnly用户zhansan
        ./mongo 127.0.0.1:27017/mydb -uroot -p123456    # 再次登录,只能针对用户所在库登录
        #虽然是超级管理员，但是admin不能直接登录其他数据库，否则报错
        #Fri Nov 22 15:03:21.886 Error: 18 { code: 18, ok: 0.0, errmsg: "auth fails" } at src/mongo/shell/db.js:228
        show collections                                # 查看链接状态 再次登录使用如下命令,显示错误未经授权
        db.system.users.find();                         # 查看创建用户信息
        db.system.users.remove({user:"zhansan"})        # 删除用户

        #恢复密码只需要重启mongodb 不加--auth参数

    }

    四、登录{

        192.168.1.5:28017      # http登录后可查看状态
        mongo                  # 默认登录后打开 test 库
        mongo 192.168.1.5:27017/databaseName      # 直接连接某个库 不存在则创建  启动认证需要指定对应库才可登录

    }

    五、查看状态{

        #登录后执行命令查看状态
        db.runCommand({"serverStatus":1})
            globalLock         # 表示全局写入锁占用了服务器多少时间(微秒)
            mem                # 包含服务器内存映射了多少数据,服务器进程的虚拟内存和常驻内存的占用情况(MB)
            indexCounters      # 表示B树在磁盘检索(misses)和内存检索(hits)的次数.如果这两个比值开始上升,就要考虑添加内存了
            backgroudFlushing  # 表示后台做了多少次fsync以及用了多少时间
            opcounters         # 包含每种主要擦撞的次数
            asserts            # 统计了断言的次数

        #状态信息从服务器启动开始计算,如果过大就会复位,发送复位，所有计数都会复位,asserts中的roolovers值增加

        #mongodb自带的命令
        ./mongostat
            insert     #每秒插入量
            query      #每秒查询量
            update     #每秒更新量
            delete     #每秒删除量
            locked     #锁定量
            qr|qw      #客户端查询排队长度(读|写)
            ar|aw      #活跃客户端量(读|写)
            conn       #连接数
            time       #当前时间

        mongostat -h 127.0.0.1 --port 27047 --authenticationDatabase admin -u zadmin -p Keaphh9e    # 查看mongo状态
        mongotop  -h 127.0.0.1 --port 27047 --authenticationDatabase admin -u zadmin -p Keaphh9e    # 查看mongo集合的统计数据

    }

    六、常用命令{

        db.listCommands()     # 当前MongoDB支持的所有命令（同样可通过运行命令db.runCommand({"listCommands" : `1})来查询所有命令）

        db.runCommand({"buildInfo" : 1})                                  # 返回MongoDB服务器的版本号和服务器OS的相关信息
        db.runCommand({"collStats" : tablename})                          # 返回该集合的统计信息，包括数据大小，已分配存储空间大小，索引的大小等
        db.runCommand({"dropDatabase" : 1})                               # 清空当前数据库的信息，包括删除所有的集合和索引
        db.runCommand({"isMaster" : 1})                                   # 检查本服务器是主服务器还是从服务器
        db.runCommand({"ping" : 1})                                       # 检查服务器链接是否正常。即便服务器上锁，该命令也会立即返回
        db.runCommand({"repaireDatabase" : 1})                            # 对当前数据库进行修复并压缩，如果数据库特别大，这个命令会非常耗时
        db.runCommand({"serverStatus" : 1})                               # 查看这台服务器的管理统计信息
        # 某些命令必须在admin数据库下运行，如下两个命令：
        db.runCommand({"renameCollection" : 集合名, "to"：集合名})          # 对集合重命名，注意两个集合名都要是完整的集合命名空间，如foo.bar, 表示数据库foo下的集合bar。
        db.runCommand({"listDatabases" : 1})                              # 列出服务器上所有的数据库

        mongo  172.20.20.1:27072/mdb --eval "db.tb.count();"              # shell执行mongo语句
        mongo --host  172.20.20.1 --port 27049

        rs.config();                                                      # 查看集群配置
        rs.status();                                                      # 查看集群节点的状态
        db.currentOp()                                                    # 获取当前正在执行的操作,可对应命令链接到ip:port
        db.runCommand( { logRotate : 1 } )                                # 日志轮转
        rs.slaveOk()                                                      # 设置从库shell可读
        rs.addArb("172.16.10.199:27020");                                 # 添加仲裁节点
        rs.add({host: "10.2.2.2:27047", priority: 0, hidden: true})       # 添加从节点 hidden true隐藏节点[priority必须为0]  false不隐藏
        rs.remove("172.20.80.216:27047");                                 # 删除节点
        rs.stepDown(120)                                                  # 主库上执行切换为从,120秒后切换回主
        show dbs                                                          # 查询db
        use post                                                          # 选择db
        show tables                                                       # 查看文档列表
        db.tb.drop()                                                      # 删除集合 需要权限
        db.tb.remove({})                                                  # 删除所有数据
        db.tb.count()                                                     # 查询文档条数
        db.tb.find()                                                      # 查看文档内容
        db.tb.find({_id:37530555})                                        # 查询指定id
        db.tb.find().sort({_id:-1}).limit(1)                              # 查询文档最后一条
        db.tb.find({"processed" : {"$ne" : true}}).limit(1);              # 字段不为 true
        db.tb.find({"processed" : {"$eq" : true}}).limit(1);              # 字段为 true
        db.tb.find({"processed" : {"$exists" : false}}).limit(1);         # 字段不存在

        db.tb.ensureIndex({"status":1}, {background:true})                # 后台加索引
        db.tb.getIndexes()                                                # 查看索引
        db.tb.ensureIndex({"c_type":1},{backgrounnd:true})                # 后台添加索引  1正向  -1反向
        db.tb.dropIndex({"c_type":1});                                    # 删除索引

    }

    七、进程控制{

        db.currentOp()                  # 查看活动进程
        db.$cmd.sys.inprog.findOne()    # 查看活动进程 与上面一样
            opid      # 操作进程号
            op        # 操作类型(查询\更新)
            ns        # 命名空间,指操作的是哪个对象
            query     # 如果操作类型是查询,这里将显示具体的查询内容
            lockType  # 锁的类型,指明是读锁还是写锁

        db.killOp(opid值)                         # 结束进程
        db.$cmd.sys.killop.findOne({op:opid值})   # 结束进程

    }

    八、备份还原{
        # mongodump 虽然能不停机备份,但是为了获取实时数据视图的能力,使用fsync命令能在运行时复制数据目录并且不会损坏数据
        # fsync会强制服务器将所有缓冲区的数据写入磁盘.配合lock还阻止对数据库的进一步写入,知道释放锁为止
        db.runCommand({"fsync":1,"lock":1})   # 执行强制更新与写入锁
        db.$cmd.sys.unlock.findOne()          # 解锁
        db.currentOp()                        # 查看解锁是否正常

        mongoexport -d test -c t1 -o t1.dat                 # 导出JSON格式
            -c         # 指明导出集合
            -d         # 使用库
        mongoexport -d test -c t1 -csv -f num -o t1.dat     # 导出csv格式
            -csv       # 指明导出csv格式
            -f         # 指明需要导出那些例

        mongoimport -d test -c t1 -file t1.dat                           # mongoimport还原JSON格式
        mongoimport -d test -c t1 -type csv --headerline -file t1.dat    # mongoimport还原csv格式数据
            --headerline                # 指明不导入第一行 因为第一行是列名

        mongodump -d test -o /bak/mongodump                # mongodump数据备份
        mongorestore -d test --drop /bak/mongodump/*       # mongorestore恢复
            --drop      # 恢复前先删除
            --gzip      # 压缩

        # 备份一个表
        # --excludeCollection string # 排除指定的集合 要排除多个，使用多个
        mongodump --host 127.0.0.1:27080 -d dbname  -c tablename  -o /data/reports/
        mongodump --host 127.0.0.1:27080 -d dbname  -c tablename  -o /data/reports/reports  -u root -p tAvaa5yNUE --authenticationDatabase admin

        # 恢复一个表
        mongorestore --host 127.0.0.1:27080 -d dbname  -c tablename --drop --dir=/data/reports/tablename.bson

        # 在线拷贝一个库
        db.copyDatabase(fromdb, todb, fromhost, username, password, mechanism)
        db.copyDatabase('mate','mate', '172.16.255.176:27047')

    }

    九、修复{

        # 当停电或其他故障引起不正常关闭时,会造成部分数据损坏丢失
        mongod --repair      # 修复操作:启动时候加上 --repair
        # 修复过程:将所有文档导出,然后马上导入,忽略无效文档.完成后重建索引。时间较长,会丢弃损坏文档
        # 修复数据还能起到压缩数据库的作用
        db.repairDatabase()    # 运行中的mongodb可使用 repairDatabase 修复当前使用的数据库
        {"repairDatabase":1}   # 通过驱动程序

    }

    十、python使用mongodb{

        原文: http://blog.nosqlfan.com/html/2989.html

        easy_install pymongo      # python2.7+
        import pymongo
        connection=pymongo.Connection('localhost',27017)   # 创建连接
        db = connection.test_database                      # 切换数据库
        collection = db.test_collection                    # 获取collection
        # db和collection都是延时创建的，在添加Document时才真正创建

        文档添加, _id自动创建
            import datetime
            post = {"author": "Mike",
                "text": "My first blog post!",
                "tags": ["mongodb", "python", "pymongo"],
                "date": datetime.datetime.utcnow()}
            posts = db.posts
            posts.insert(post)
            ObjectId('...')

        批量插入
            new_posts = [{"author": "Mike",
                "text": "Another post!",
                "tags": ["bulk", "insert"],
                "date": datetime.datetime(2009, 11, 12, 11, 14)},
                {"author": "Eliot",
                "title": "MongoDB is fun",
                "text": "and pretty easy too!",
                "date": datetime.datetime(2009, 11, 10, 10, 45)}]
            posts.insert(new_posts)
            [ObjectId('...'), ObjectId('...')]

        获取所有collection
            db.collection_names()    # 相当于SQL的show tables

        获取单个文档
            posts.find_one()

        查询多个文档
            for post in posts.find():
                post

        加条件的查询
            posts.find_one({"author": "Mike"})

        高级查询
            posts.find({"date": {"$lt": "d"}}).sort("author")

        统计数量
            posts.count()

        加索引
            from pymongo import ASCENDING, DESCENDING
            posts.create_index([("date", DESCENDING), ("author", ASCENDING)])

        查看查询语句的性能
            posts.find({"date": {"$lt": "d"}}).sort("author").explain()["cursor"]
            posts.find({"date": {"$lt": "d"}}).sort("author").explain()["nscanned"]

    }

}

JDK安装{

    vim /etc/profile.d/jdk.sh
    export JAVA_HOME=/usr/local/jdk1.8.0_151
    export PATH=$JAVA_HOME/bin:$PATH

    . /etc/profile         # 加载新的环境变量
    jps -ml                # 查看java进程
    jstat -gc 18381 1s 30  # 查看java进程gc情况
}

redis动态加内存{

    ./redis-cli -h 10.10.10.11 -p 6401
    save                                # 保存当前快照
    config get *                        # 列出所有当前配置
    config get maxmemory                # 查看指定配置
    config set maxmemory  15360000000   # 动态修改最大内存配置参数

}

nfs{

    # 依赖rpc服务通信 portmap[centos5] 或 rpcbind[centos6]
    yum install nfs-utils portmap    # centos5安装
    yum install nfs-utils rpcbind    # centos6安装

    vim /etc/exports                 # 配置文件
    # sync                           # 同步写入
    # async                          # 暂存并非直接写入
    # no_root_squash                 # 开放用户端使用root身份操作
    # root_squash                    # 使用者身份为root则被压缩成匿名使用,即nobody,相对安全
    # all_squash                     # 所有NFS的使用者身份都被压缩为匿名
    /data/images 10.10.10.0/24(rw,sync,no_root_squash)

    service  portmap restart         # 重启centos5的nfs依赖的rpc服务
    service  rpcbind restart         # 重启centos6的nfs依赖的rpc服务
    service  nfs restart             # 重启nfs服务  确保依赖 portmap 或 rpcbind 服务已启动
    service  nfs reload              # 重载NFS服务配置文件
    showmount -e                     # 服务端查看自己共享的服务
    showmount -a                     # 显示已经与客户端连接上的目录信息
    showmount -e 10.10.10.3          # 列出服务端可供使用的NFS共享  客户端测试能否访问nfs服务
    mount -t nfs 10.10.10.3:/data/images/  /data/img   # 挂载nfs  如果延迟影响大加参数 noac

    # 服务端的 portmap 或 rpcbind 被停止后，nfs仍然工作正常，但是umout财会提示： not found / mounted or server not reachable  重启服务器的portmap 或 rpcbind 也无济于事。 nfs也要跟着重启，否则nfs工作仍然是不正常的。
    # 同时已挂载会造成NFS客户端df卡住和挂载目录无法访问。请先用 mount 查看当前挂载情况，记录挂载信息，在强制卸载挂载目录，重新挂载
    umount -f /data/img/             # 强制卸载挂载目录  如还不可以  umount -l /data/img/

    nfsstat -c                       # 客户机发送和拒绝的RPC和NFS调用数目的信息
    nfsstat -cn                      # 显示和打印与客户机NFS调用相关的信息
    nfsstat -r                       # 显示和打印客户机和服务器的与RPC调用相关的信息
    nfsstat –s                       # 显示关于服务器接收和拒绝的RPC和NFS调用数目的信息

}

hdfs{
    hdfs --help                  # 所有参数

    hdfs dfs -help               # 运行文件系统命令在Hadoop文件系统
    hdfs dfs -ls /logs           # 查看
    hdfs dfs -ls /user/          # 查看用户
    hdfs dfs -cat
    hdfs dfs -df
    hdfs dfs -du
    hdfs dfs -rm
    hdfs dfs -tail
    hdfs dfs –put localSrc dest  # 上传文件

    hdfs dfsadmin -help          # hdfs集群节点管理
    hdfs dfsadmin -report        # 基本的文件系统统计信息
}
</code></pre>
<h2 id="5-网络"><a href="#5-网络" class="headerlink" title="5 网络"></a>5 网络</h2><pre><code>rz                                                                    # 通过ssh上传小文件
sz                                                                    # 通过ssh下载小文件
ifconfig eth0 down                                                    # 禁用网卡
ifconfig eth0 up                                                      # 启用网卡
ifup eth0:0                                                           # 启用网卡
mii-tool em1                                                          # 查看网线是否连接
traceroute www.baidu.com                                              # 测试跳数
vi /etc/resolv.conf                                                   # 设置DNS  nameserver IP 定义DNS服务器的IP地址
nslookup www.moon.com                                                 # 解析域名IP
dig -x www.baidu.com                                                  # 解析域名IP
dig +trace -t A domainname                                            # 跟踪dns
dig +short txt hacker.wp.dg.cx                                        # 通过 DNS 来读取 Wikipedia 的hacker词条
host -t txt hacker.wp.dg.cx                                           # 通过 DNS 来读取 Wikipedia 的hacker词条
lynx                                                                  # 文本上网
wget -P path -O name url                                              # 下载  包名:wgetrc   -q 安静 -c 续传
dhclient eth1                                                         # 自动获取IP
mtr -r www.baidu.com                                                  # 测试网络链路节点响应时间 # trace ping 结合
ipcalc -m "$ip" -p "$num"                                             # 根据IP和主机最大数计算掩码
curl -I www.baidu.com                                                 # 查看网页http头
curl -s www.baidu.com                                                 # 不显示进度
queryperf -d list -s DNS_IP -l 2                                      # BIND自带DNS压力测试  [list 文件格式:www.turku.fi A]
telnet ip port                                                        # 测试端口是否开放,有些服务可直接输入命令得到返回状态
echo "show " |nc $ip $port                                            # 适用于telnet一类登录得到命令返回
nc -l -p port                                                         # 监听指定端口
nc -nv -z 10.10.10.11 1080 |grep succeeded                            # 检查主机端口是否开放
curl -o /dev/null -s -m 10 --connect-timeout 10 -w %{http_code} $URL  # 检查页面状态
curl -X POST -d "user=xuesong&amp;pwd=123" http://www.abc.cn/Result       # 提交POST请求
curl -s http://20140507.ip138.com/ic.asp                              # 通过IP138取本机出口外网IP
curl http://IP/ -H "X-Forwarded-For: ip" -H "Host: www.ttlsa.com"     # 连到指定IP的响应主机,HTTPserver只看 Host字段
ifconfig eth0:0 192.168.1.221 netmask 255.255.255.0                   # 增加逻辑IP地址
echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all                      # 禁ping
net rpc shutdown -I IP_ADDRESS -U username%password                   # 远程关掉一台WINDOWS机器
wget --random-wait -r -p -e robots=off -U Mozilla www.example.com     # 递归方式下载整个网站
sshpass -p "$pwd" rsync -avzP /dir  user@$IP:/dir/                    # 指定密码避免交互同步目录
rsync -avzP --delete /dir/ user@$IP:/dir/                             # 无差同步目录 可以快速清空大目录,末尾带/同步目录
rsync -avzP -e "ssh -p 22 -e -o StrictHostKeyChecking=no" /dir user@$IP:/dir         # 指定ssh参数同步

抓包{

    -i eth1                             # 只抓经过接口eth1的包
    -t                                  # 不显示时间戳
    -s 0                                # 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
    -c 100                              # 只抓取100个数据包
    dst port ! 22                       # 不抓取目标端口是22的数据包
    tcpdump tcp port 22                 # 抓包
    tcpdump -n -vv udp port 53          # 抓udp的dns包 并显示ip
    tcpdump port 10001 -A -s0           # 完整显示ascii数据包
    tcpdump -i any  host x.x.x.x -s 0 -w /tmp/cap.pcap   # 对端ip
    tcpdump -i any -s 0 host 172.20.81.107 or host 172.16.3.72 -C 50 -W 5 -w /tmp/20190122ng.cap

}


一次短链接失败故障定位{

    # php和python程序调用接口,通过阿里云slb,到后端nginx,偶尔超时,后端nginx无请求,怀疑没到nginx,但通过检查,无法与nginx建立tcp链接
    ss -nl |grep :80  # 查看 accept 队列值,短连接应该大一点
    watch -n 1 'nstat -z -t 1 | grep -e TcpActiveOpens -e TcpExtListenOverflows -e TcpAttemptFails -e TcpPassiveOpen -e TcpExtTCPSynRetrans -e TcpRetransSegs  -e TcpOutSegs -e TcpInSegs'

    TcpAttemptFails         TCP建立链接失败,包括前后端
    TcpExtTCPSynRetrans     TCP向后端建立链接失败


    # nginx 和内核都需要调整才生效,程序监听端口,需要加socket参数
    listen 10.87.128.29:51528 default_server backlog=4096;


    https://m.aliyun.com/yunqi/articles/118472?spm=5176.8091938.0.0.11e86ccF4oOeZ
}

网卡流量查看{

    watch more /proc/net/dev    # 实时监控流量文件系统 累计值
    iptraf                      # 网卡流量查看工具
    nethogs -d 5 eth0 eth1      # 按进程实时统计网络流量 epel源nethogs
    iftop -i eth0 -n -P         # 实时流量监控

    sar {
        -n参数有6个不同的开关: DEV | EDEV | NFS | NFSD | SOCK | ALL
        DEV显示网络接口信息
        EDEV显示关于网络错误的统计数据
        NFS统计活动的NFS客户端的信息
        NFSD统计NFS服务器的信息
        SOCK显示套 接字信息
        ALL显示所有5个开关

        sar -n DEV 1 10

        rxpck/s   # 每秒钟接收的数据包
        txpck/s   # 每秒钟发送的数据包
        rxbyt/s   # 每秒钟接收的字节数
        txbyt/s   # 每秒钟发送的字节数
        rxcmp/s   # 每秒钟接收的压缩数据包
        txcmp/s   # 每秒钟发送的压缩数据包
        rxmcst/s  # 每秒钟接收的多播数据包

    }

}

netstat{

    # 几十万并发的情况下netstat会没有响应，建议使用 ss 命令
    -a     # 显示所有连接中的Socket
    -t     # 显示TCP连接
    -u     # 显示UDP连接
    -n     # 显示所有已建立的有效连接
    netstat -anlp           # 查看链接
    netstat -tnlp           # 只查看tcp监听端口
    netstat -r              # 查看路由表
}

ss{

    # netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多
    ss -s                          # 列出当前socket详细信息
    ss -l                          # 显示本地打开的所有端口
    ss -tnlp                       # 显示每个进程具体打开的socket
    ss -ant                        # 显示所有TCP socket
    ss -u -a                       # 显示所有UDP Socekt
    ss dst 192.168.119.113         # 匹配远程地址
    ss dst 192.168.119.113:http    # 匹配远程地址和端口号
    ss dst 192.168.119.113:3844    # 匹配远程地址和端口号
    ss src 192.168.119.103:16021   # 匹配本地地址和端口号
    ss -o state established '( dport = :smtp or sport = :smtp )'        # 显示所有已建立的SMTP连接
    ss -o state established '( dport = :http or sport = :http )'        # 显示所有已建立的HTTP连接
    ss -x src /tmp/.X11-unix/*         # 找出所有连接X服务器的进程

}

并发数查看{

    netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
    SYN_RECV     # 正在等待处理的请求
    ESTABLISHED  # 正常数据传输状态,既当前并发数
    TIME_WAIT    # 处理完毕，等待超时结束的请求
    CLOSE_WAIT   # 客户端异常关闭,没有完成4次挥手  如大量可能存在攻击行为

}

ssh{

    ssh -p 22 user@192.168.1.209                            # 从linux ssh登录另一台linux
    ssh -p 22 root@192.168.1.209 CMD                        # 利用ssh操作远程主机
    scp -P 22 file root@ip:/dir                             # 把本地文件拷贝到远程主机
    scp -l 100000  file root@ip:/dir                        # 传输文件到远程，限制速度100M
    sshpass -p 'pwd' ssh -n root@$IP "echo hello"           # 指定密码远程操作
    ssh -o StrictHostKeyChecking=no $IP                     # ssh连接不提示yes
    ssh -t "su -"                                           # 指定伪终端 客户端以交互模式工作
    scp root@192.168.1.209:/RemoteDir /localDir             # 把远程指定文件拷贝到本地
    pscp -h host.ip /a.sh /opt/sbin/                        # 批量传输文件
    ssh -N -L2001:remotehost:80 user@somemachine            # 用SSH创建端口转发通道
    ssh -t host_A ssh host_B                                # 嵌套使用SSH
    ssh -t -p 22 $user@$Ip /bin/su - root -c {$Cmd};        # 远程su执行命令 Cmd="\"/sbin/ifconfig eth0\""
    ssh-keygen -t rsa                                       # 生成密钥
    ssh-copy-id -i xuesong@10.10.10.133                     # 传送key
    vi $HOME/.ssh/authorized_keys                           # 公钥存放位置
    sshfs name@server:/path/to/folder /path/to/mount/point  # 通过ssh挂载远程主机上的文件夹
    fusermount -u /path/to/mount/point                      # 卸载ssh挂载的目录
    ssh user@host cat /path/to/remotefile | diff /path/to/localfile -                # 用DIFF对比远程文件跟本地文件
    su - user -c "ssh user@192.168.1.1 \"echo -e aa |mail -s test mail@163.com\""    # 切换用户登录远程发送邮件
    pssh -h ip.txt -i uptime                                # 批量执行ssh yum install pssh

    SSH反向连接{

        # 外网A要控制内网B

        ssh -NfR 1234:localhost:2223 user1@123.123.123.123 -p22    # 将A主机的1234端口和B主机的2223端口绑定，相当于远程端口映射
        ss -ant   # 这时在A主机上sshd会listen本地1234端口
        # LISTEN     0    128    127.0.0.1:1234       *:*
        ssh localhost -p1234    # 在A主机连接本地1234端口

    }
}

网卡配置文件{

    vi /etc/sysconfig/network-scripts/ifcfg-eth0

    DEVICE=eth0
    BOOTPROTO=none
    BROADCAST=192.168.1.255
    HWADDR=00:0C:29:3F:E1:EA
    IPADDR=192.168.1.55
    NETMASK=255.255.255.0
    NETWORK=192.168.1.0
    ONBOOT=yes
    TYPE=Ethernet
    GATEWAY=192.168.1.1
    #ARPCHECK=no     # 进制arp检查

}

route {

    route                           # 查看路由表
    route add default  gw 192.168.1.1  dev eth0                        # 添加默认路由
    route add -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 添加静态路由网关
    route del -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 删除静态路由网关

}

静态路由{

    vim /etc/sysconfig/static-routes
    any net 192.168.12.0/24 gw 192.168.0.254
    any net 192.168.13.0/24 gw 192.168.0.254

}

解决ssh链接慢{

    sed -i 's/GSSAPIAuthentication yes/GSSAPIAuthentication no/' /etc/ssh/sshd_config
    sed -i '/#UseDNS yes/a\UseDNS no' /etc/ssh/sshd_config
    /etc/init.d/sshd reload

}

nmap{

    nmap -PT 192.168.1.1-111             # 先ping在扫描主机开放端口
    nmap -O 192.168.1.1                  # 扫描出系统内核版本
    nmap -sV 192.168.1.1-111             # 扫描端口的软件版本
    nmap -sS 192.168.1.1-111             # 半开扫描(通常不会记录日志)
    nmap -P0 192.168.1.1-111             # 不ping直接扫描
    nmap -d 192.168.1.1-111              # 详细信息
    nmap -D 192.168.1.1-111              # 无法找出真正扫描主机(隐藏IP)
    nmap -p 20-30,139,60000-             # 端口范围  表示：扫描20到30号端口，139号端口以及所有大于60000的端口
    nmap -P0 -sV -O -v 192.168.30.251    # 组合扫描(不ping、软件版本、内核版本、详细信息)

    # 不支持windows的扫描(可用于判断是否是windows)
    nmap -sF 192.168.1.1-111
    nmap -sX 192.168.1.1-111
    nmap -sN 192.168.1.1-111

}

流量切分线路{

    # 程序判断进入IP线路，设置服务器路由规则控制返回
    vi /etc/iproute2/rt_tables
    #添加一条策略
    252   bgp2  #注意策略的序号顺序
    ip route add default via 第二个出口上线IP(非默认网关) dev eth1 table bgp2
    ip route add from 本机第二个ip table bgp2
    #查看
    ip route list table 252
    ip rule list
    #成功后将语句添加开机启动

}

snmp{

    snmptranslate .1.3.6.1.2.1.1.3.0    # 查看映射关系
        DISMAN-EVENT-MIB::sysUpTimeInstance
    snmpdf -v 1 -c public localhost                            # SNMP监视远程主机的磁盘空间
    snmpnetstat -v 2c -c public -a 192.168.6.53                # SNMP获取指定IP的所有开放端口状态
    snmpwalk -v 2c -c public 10.152.14.117 .1.3.6.1.2.1.1.3.0  # SNMP获取主机启动时间
    # MIB安装(ubuntu)
    # sudo apt-get install snmp-mibs-downloader
    # sudo download-mibs
    snmpwalk -v 2c -c public 10.152.14.117 sysUpTimeInstance   # SNMP通过MIB库获取主机启动时间

}

TC流量控制{

    # 针对ip段下载速率控制
    tc qdisc del dev eth0 root handle 1:                                                              # 删除控制1:
    tc qdisc add dev eth0 root handle 1: htb r2q 1                                                    # 添加控制1:
    tc class add dev eth0 parent 1: classid 1:1 htb rate 12mbit ceil 15mbit                           # 设置速率
    tc filter add dev eth0 parent 1: protocol ip prio 16 u32 match ip dst 10.10.10.1/24 flowid 1:1    # 指定ip段控制规则

    # 检查命令
    tc -s -d qdisc show dev eth0
    tc class show dev eth0
    tc filter show dev eth0

    限制上传下载{

        tc qdisc del dev tun0 root
        tc qdisc add dev tun0 root handle 2:0 htb
        tc class add dev tun0 parent 2:1 classid 2:10 htb rate 30kbps
        tc class add dev tun0 parent 2:2 classid 2:11 htb rate 30kbps
        tc qdisc add dev tun0 parent 2:10 handle 1: sfq perturb 1
        tc filter add dev tun0 protocol ip parent 2:0 u32 match ip dst 10.18.0.0/24 flowid 2:10
        tc filter add dev tun0 parent ffff: protocol ip u32 match ip src 10.18.0.0/24 police rate 30kbps burst 10k drop flowid 2:11


        tc qdisc del dev tun0 root                                     # 删除原有策略
        tc qdisc add dev tun0 root handle 2:0 htb                      # 定义最顶层(根)队列规则，并指定 default 类别编号，为网络接口 eth1 绑定一个队列，类型为 htb，并指定了一个 handle 句柄 2:0 用于标识它下面的子类
        tc class add dev tun0 parent 2:1 classid 2:10 htb rate 30kbps  # 设置一个规则速度是30kbps
        tc class add dev tun0 parent 2:2 classid 2:11 htb rate 30kbps
        tc qdisc add dev tun0 parent 2:10 handle 1: sfq perturb 1      # 调用随机公平算法
        tc filter add dev tun0 protocol ip parent 2:0 u32 match ip dst 10.18.0.0/24 flowid 2:10  # 规则2:10应用在目标地址上，即下载
        tc filter add dev tun0 parent ffff: protocol ip u32 match ip src 10.18.0.0/24 police rate 30kbps burst 10k drop flowid 2:11 # 上传限速

    }

}
</code></pre>
<h2 id="6-磁盘"><a href="#6-磁盘" class="headerlink" title="6 磁盘"></a>6 磁盘</h2><pre><code>df -Ph                                          # 查看硬盘容量
df -T                                           # 查看磁盘分区格式
df -i                                           # 查看inode节点   如果inode用满后无法创建文件
du -h dir                                       # 检测目录下所有文件大小
du -sh *                                        # 显示当前目录中子目录的大小
mount -l                                        # 查看分区挂载情况
fdisk -l                                        # 查看磁盘分区状态
fdisk /dev/hda3                                 # 分区
mkfs -t ext4  /dev/hda3                         # 格式化分区
fsck -y /dev/sda6                               # 对文件系统修复
lsof |grep delete                               # 释放进程占用磁盘空间  列出进程后，查看文件是否存在，不存在则kill掉此进程
tmpwatch -afv 10   /tmp                         # 删除10小时内未使用的文件  勿在重要目录使用
cat /proc/filesystems                           # 查看当前系统支持文件系统
mount -o remount,rw /                           # 修改只读文件系统为读写
iotop                                           # 进程占用磁盘IO情况   yum install iotop
smartctl -H /dev/sda                            # 检测硬盘状态  # yum install smartmontools
smartctl -i /dev/sda                            # 检测硬盘信息
smartctl -a /dev/sda                            # 检测所有信息
e2label /dev/sda5                               # 查看卷标
e2label /dev/sda5 new-label                     # 创建卷标
ntfslabel -v /dev/sda8 new-label                # NTFS添加卷标
tune2fs -j /dev/sda                             # ext2分区转ext3分区
tune2fs -l /dev/sda                             # 查看文件系统信息
mke2fs -b 2048 /dev/sda5                        # 指定索引块大小
dumpe2fs -h /dev/sda5                           # 查看超级块的信息
mount -t iso9660 /dev/dvd  /mnt                 # 挂载光驱
mount -t ntfs-3g /dev/sdc1 /media/yidong        # 挂载ntfs硬盘
mount -t nfs 10.0.0.3:/opt/images/  /data/img   # 挂载nfs 需要重载 /etc/init.d/nfs reload  重启需要先启动 portmap 服务
mount -o loop  /software/rhel4.6.iso   /mnt/    # 挂载镜像文件

磁盘IO性能检测{

    iostat -x 1 10

    % user       # 显示了在用户级(应用程序)执行时生成的 CPU 使用率百分比。
    % system     # 显示了在系统级(内核)执行时生成的 CPU 使用率百分比。
    % idle       # 显示了在 CPU 空闲并且系统没有未完成的磁盘 I/O 请求时的时间百分比。
    % iowait     # 显示了 CPU 空闲期间系统有未完成的磁盘 I/O 请求时的时间百分比。

    rrqm/s       # 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
    wrqm/s       # 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
    r/s          # 每秒完成的读 I/O 设备次数。即 delta(rio)/s
    w/s          # 每秒完成的写 I/O 设备次数。即 delta(wio)/s
    rsec/s       # 每秒读扇区数。即 delta(rsect)/s
    wsec/s       # 每秒写扇区数。即 delta(wsect)/s
    rkB/s        # 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
    wkB/s        # 每秒写K字节数。是 wsect/s 的一半。(需要计算)
    avgrq-sz     # 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
    avgqu-sz     # 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
    await        # 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
    svctm        # 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
    %util        # 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)

    IO性能衡量标准{

        1、 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
        2、 idle 小于70% IO压力就较大了,一般读取速度有较多的wait.
        3、 同时可以结合 vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)
        4、 svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了),svctm 的大小一般和磁盘性能有关,CPU/内存的负荷也会对其有影响,请求过多也会间接导致 svctm 的增加. await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式. 如果 svctm 比较接近 await,说明 I/O 几乎没有等待时间;如果 await 远大于 svctm,说明 I/O 队列太长,应用得到的响应时间变慢,如果响应时间超过了用户可以容许的范围,这时可以考虑更换更快的磁盘,调整内核 elevator 算法,优化应用,或者升级 CPU
        5、 队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。

    }

}

iotop{

    # 监视进程磁盘I/O

    yum install iotop

    -o        # 只显示有io操作的进程
    -b        # 批量显示，无交互，主要用作记录到文件。
    -n NUM    # 显示NUM次，主要用于非交互式模式。
    -d SEC    # 间隔SEC秒显示一次。
    -p PID    # 监控的进程pid。
    -u USER   # 监控的进程用户。

    # 左右箭头：改变排序方式，默认是按IO排序。
    r         # 改变排序顺序。
    o         # 只显示有IO输出的进程。
    p         # 进程/线程的显示方式的切换。
    a         # 显示累积使用量。
    q         # 退出。

}

创建swap文件方法{

    dd if=/dev/zero of=/swap bs=1024 count=4096000            # 创建一个足够大的文件
    # count的值等于1024 x 你想要的文件大小, 4096000是4G
    mkswap /swap                      # 把这个文件变成swap文件
    swapon /swap                      # 启用这个swap文件
    /swap swap swap defaults 0 0      # 在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行
    cat /proc/swaps                   # 查看swap
    swapoff -a                        # 关闭swap
    swapon -a                         # 开启swap

}

新硬盘挂载{

    fdisk /dev/sdc
    p    #  打印分区
    d    #  删除分区
    n    #  创建分区，（一块硬盘最多4个主分区，扩展占一个主分区位置。p主分区 e扩展）
    w    #  保存退出
    mkfs.ext4 -L 卷标  /dev/sdc1            # 格式化相应分区
    mount /dev/sdc1  /mnt                  # 挂载
    vi /etc/fstab                          # 添加开机挂载分区
    LABEL=/data            /data                   ext4    defaults        1 2      # 用卷标挂载
    /dev/sdb1              /data4                  ext4    defaults        1 2      # 用真实分区挂载
    /dev/sdb2              /data4                  ext4    noatime,defaults        1 2

    第一个数字"1"该选项被"dump"命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0
    第二个数字"2"该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统"/"对应该字段的值应该为1，其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0
    当以 noatime 选项加载（mount）文件系统时，对文件的读取不会更新文件属性中的atime信息。设置noatime的重要性是消除了文件系统对文件的写操作，文件只是简单地被系统读取。由于写操作相对读来说要更消耗系统资源，所以这样设置可以明显提高服务器的性能.wtime信息仍然有效，任何时候文件被写，该信息仍被更新。

    mount -a    # 自动加载 fstab 文件挂载，避免配置错误，系统无法重启

}

大磁盘2T和16T分区{

    parted /dev/sdb                # 针对磁盘分区
    (parted) mklabel gpt           # 设置为 gpt
    (parted) print
    (parted) mkpart  primary 0KB 22.0TB        # 指定分区大小
    Is this still acceptable to you?
    Yes/No? Yes
    Ignore/Cancel? Ignore
    (parted) print
    Model: LSI MR9271-8i (scsi)
    Disk /dev/sdb: 22.0TB
    Sector size (logical/physical): 512B/512B
    Partition Table: gpt
    Number  Start   End     Size    File system  Name     Flags
     1      17.4kB  22.0TB  22.0TB               primary
    (parted) quit

    mkfs.ext4 /dev/sdb1        # e2fsprogs升级后支持大于16T硬盘

    # 大于16T的单个分区ext4格式化报错，需要升级e2fsprogs
    Size of device /dev/sdb1 too big to be expressed in 32 bits using a blocksize of 4096.

    yum -y install xfsprogs
    mkfs.xfs -f /dev/sdb1              # 大于16T单个分区也可以使用XFS分区,但inode占用很大,对大量的小文件支持不太好

}

阿里云扩容磁盘{

    # 进入ECS 本实例磁盘，勾选在线扩容, 选择扩容磁盘
    yum install cloud-utils-growpart
    yum install xfsprogs
    df -h    # 查看目前分区大小
    fdisk -l # 查看磁盘设备
    growpart /dev/vda 1         # 扩容分区 如果没有分区,默认整块,不需要执行
    resize2fs /dev/vda1         # 扩容文件系统 ext4文件系统 
    xfs_growfs /dev/vda1        # 扩容文件系统 xfs文件系统
    df -h                       # 再查看分区大小,是否扩容

}

raid原理与区别{

    raid0至少2块硬盘.吞吐量大,性能好,同时读写,但损坏一个就完蛋
    raid1至少2块硬盘.相当镜像,一个存储,一个备份.安全性比较高.但是性能比0弱
    raid5至少3块硬盘.分别存储校验信息和数据，坏了一个根据校验信息能恢复
    raid6至少4块硬盘.两个独立的奇偶系统,可坏两块磁盘,写性能非常差

}
</code></pre>
<h2 id="7-用户"><a href="#7-用户" class="headerlink" title="7 用户"></a>7 用户</h2><pre><code>users                                      # 显示所有的登录用户
groups                                     # 列出当前用户和他所属的组
who -q                                     # 显示所有的登录用户
groupadd                                   # 添加组
useradd user                               # 建立用户
passwd username                            # 修改密码
userdel -r                                 # 删除帐号及家目录
chown -R user:group                        # 修改目录拥有者(R递归)
chown y\.li:mysql                          # 修改所有者用户中包含点"."
umask                                      # 设置用户文件和目录的文件创建缺省屏蔽值
chgrp                                      # 修改用户组
finger                                     # 查找用户显示信息
echo "xuesong" | passwd user --stdin       # 非交互修改密码
useradd -g www -M  -s /sbin/nologin  www   # 指定组并不允许登录的用户,nologin允许使用服务
useradd -g www -M  -s /bin/false  www      # 指定组并不允许登录的用户,false最为严格
useradd -d /data/song -g song song         # 创建用户并指定家目录和组
usermod -l newuser olduser                 # 修改用户名
usermod -g user group                      # 修改用户所属组
usermod -d dir -m user                     # 修改用户家目录
usermod -G group user                      # 将用户添加到附加组
gpasswd -d user group                      # 从组中删除用户
su - user -c " #cmd1; "                    # 切换用户执行

恢复密码{

    # 即进入单用户模式: 在linux出现grub后，在安装的系统上面按"e"，然后出现grub的配置文件，按键盘移动光标到第二行"Ker……"，再按"e"，然后在这一行的结尾加上：空格 single或者空格1回车，然后按"b"重启，就进入了"单用户模式"
}

特殊权限{

    s或 S （SUID）：对应数值4
    s或 S （SGID）：对应数值2
    t或 T ：对应数值1
    大S：代表拥有root权限，但是没有执行权限
    小s：拥有特权且拥有执行权限，这个文件可以访问系统任何root用户可以访问的资源
    T或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件

}
</code></pre>
<h2 id="8-脚本"><a href="#8-脚本" class="headerlink" title="8 脚本"></a>8 脚本</h2><pre><code>#!/bin/sh                             # 在脚本第一行脚本头 # sh为当前系统默认shell,可指定为bash等shell
shopt                                 # 显示和设置shell中的行为选项
sh -x                                 # 执行过程
sh -n                                 # 检查语法
set -e                                # 若指令传回值不等于0，则立即退出shell
(a=bbk)                               # 括号创建子shell运行
basename /a/b/c                       # 从全路径中保留最后一层文件名或目录
dirname                               # 取路径
$RANDOM                               # 随机数
$$                                    # 进程号
source FileName                       # 在当前bash环境下读取并执行FileName中的命令  # 等同 . FileName
sleep 5                               # 间隔睡眠5秒
trap                                  # 在接收到信号后将要采取的行动
trap "" 2 3                           # 禁止ctrl+c
$PWD                                  # 当前目录
$HOME                                 # 家目录
$OLDPWD                               # 之前一个目录的路径
cd -                                  # 返回上一个目录路径
local ret                             # 局部变量
yes                                   # 重复打印
yes |rm -i *                          # 自动回答y或者其他
ls -p /home                           # 区分目录和文件夹
ls -d /home/                          # 查看匹配完整路径
time a.sh                             # 测试程序执行时间
echo -n aa;echo bb                    # 不换行执行下一句话 将字符串原样输出
echo -e "s\tss\n\n\n"                 # 使转义生效
echo $a | cut -c2-6                   # 取字符串中字元
echo {a,b,c}{a,b,c}{a,b,c}            # 排列组合(括号内一个元素分别和其他括号内元素组合)
echo $((2#11010))                     # 二进制转10进制
echo aaa | tee file                   # 打印同时写入文件 默认覆盖 -a追加
echo {1..10}                          # 打印10个字符
printf '%10s\n'|tr " " a              # 打印10个字符
pwd | awk -F/ '{ print $2 }'          # 返回目录名
tac file |sed 1,3d|tac                # 倒置读取文件  # 删除最后3行
tail -3 file                          # 取最后3行
outtmp=/tmp/$$`date +%s%N`.outtmp     # 临时文件定义
:(){ :|:&amp; };:                         # fork炸弹,系统执行海量的进程,直到系统僵死
echo -e "\e[32mcolour\e[0m"           # 打印颜色
echo -e "\033[32mcolour\033[m"        # 打印颜色
echo -e "\033[0;31mL\033[0;32mO\033[0;33mV\033[0;34mE\t\033[0;35mY\033[0;36mO\033[0;32mU\e[m"    # 打印颜色

正则表达式{

    ^                       # 行首定位
    $                       # 行尾定位
    .                       # 匹配除换行符以外的任意字符
    *                       # 匹配0或多个重复字符
    +                       # 重复一次或更多次
    ?                       # 重复零次或一次
    ?                       # 结束贪婪因子 .*? 表示最小匹配
    []                      # 匹配一组中任意一个字符
    [^]                     # 匹配不在指定组内的字符
    \                       # 用来转义元字符
    &lt;                       # 词首定位符(支持vi和grep)  &lt;love
    &gt;                       # 词尾定位符(支持vi和grep)  love&gt;
    x\{m\}                  # 重复出现m次
    x\{m,\}                 # 重复出现至少m次
    x\{m,n\}                # 重复出现至少m次不超过n次
    X?                      # 匹配出现零次或一次的大写字母 X
    X+                      # 匹配一个或多个字母 X
    ()                      # 括号内的字符为一组
    (ab|de)+                # 匹配一连串的（最少一个） abc 或 def；abc 和 def 将匹配
    [[:alpha:]]             # 代表所有字母不论大小写
    [[:lower:]]             # 表示小写字母
    [[:upper:]]             # 表示大写字母
    [[:digit:]]             # 表示数字字符
    [[:digit:][:lower:]]    # 表示数字字符加小写字母

    元字符{

        \d       # 匹配任意一位数字
        \D       # 匹配任意单个非数字字符
        \w       # 匹配任意单个字母数字下划线字符，同义词是 [:alnum:]
        \W       # 匹配非数字型的字符

    }

    字符类:空白字符{

        \s       # 匹配任意的空白符
        \S       # 匹配非空白字符
        \b       # 匹配单词的开始或结束
        \n       # 匹配换行符
        \r       # 匹配回车符
        \t       # 匹配制表符
        \b       # 匹配退格符
        \0       # 匹配空值字符

    }

    字符类:锚定字符{

        \b       # 匹配字边界(不在[]中时)
        \B       # 匹配非字边界
        \A       # 匹配字符串开头
        \Z       # 匹配字符串或行的末尾
        \z       # 只匹配字符串末尾
        \G       # 匹配前一次m//g离开之处

    }

    捕获{

        (exp)                # 匹配exp,并捕获文本到自动命名的组里
        (?&lt;name&gt;exp)         # 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
        (?:exp)              # 匹配exp,不捕获匹配的文本，也不给此分组分配组号

    }

    零宽断言{

        (?=exp)              # 匹配exp前面的位置
        (?&lt;=exp)             # 匹配exp后面的位置
        (?!exp)              # 匹配后面跟的不是exp的位置
        (?&lt;!exp)             # 匹配前面不是exp的位置
        (?#comment)          # 注释不对正则表达式的处理产生任何影响，用于注释

    }

    特殊字符{

        http://en.wikipedia.org/wiki/Ascii_table
        ^H  \010 \b
        ^M  \015 \r
        匹配特殊字符: ctrl+V ctrl不放在按H或M 即可输出^H,用于匹配

    }

}

流程结构{

    if判断{

        if [ $a == $b ]
        then
            echo "等于"
        else
            echo "不等于"
        fi

    }

    case分支选择{

        case $xs in
        0) echo "0" ;;
        1) echo "1" ;;
        *) echo "其他" ;;
        esac

    }

    while循环{

        # while true  等同   while :
        # 读文件为整行读入
        num=1
        while [ $num -lt 10 ]
        do
        echo $num
        ((num=$num+2))
        done
        ###########################
        grep a  a.txt | while read a
        do
            echo $a
        done
        ###########################
        while read a
        do
            echo $a
        done &lt; a.txt

    }

    for循环{

        # 读文件已空格分隔
        w=`awk -F ":" '{print $1}' c`
        for d in $w
        do
            $d
        done
        ###########################
        for ((i=0;i&lt;$
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">路遥</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://friesroad.github.io/2023/07/31/shell-shi-li-shou-ce/">https://friesroad.github.io/2023/07/31/shell-shi-li-shou-ce/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">路遥</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%B5%8B%E8%AF%95/">
                                    <span class="chip bg-color">测试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2023-07-31T10-36-51',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/08/03/guan-yu-adapter-gou-jian-ding-shi-ren-wu-shi-bai-de-wen-ti/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="关于adapter构建定时任务时总会中途卡死的问题">
                        
                        <span class="card-title">关于adapter构建定时任务时总会中途卡死的问题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            默认摘要
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-08-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/" class="post-category">
                                    默认分类
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B5%8B%E8%AF%95/">
                        <span class="chip bg-color">测试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/28/guan-yu-hai-yun-wu-fa-huo-qu-es-zhong-ri-zhi-de-wen-ti/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="关于海云无法获取es中日志的问题">
                        
                        <span class="card-title">关于海云无法获取es中日志的问题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            默认摘要
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/" class="post-category">
                                    默认分类
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B5%8B%E8%AF%95/">
                        <span class="chip bg-color">测试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('10')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: luyao&#39;s home<br />'
            + '文章作者: 路遥<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="artist"
                   id="12138269"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">路遥</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://friesroad.github.io/" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">102.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "2";
                        var startDate = "1";
                        var startHour = "8";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
                <span id="icp"><img src="/medias/icp.png"
                                    style="vertical-align: text-bottom;"/>
                <a href="/null" target="_blank"></a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://friesroad.github.io/" class="tooltipped" target="https://friesroad.github.io/" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:xi.yu@trs.com.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1650138106" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1650138106" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "https://friesroad.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
